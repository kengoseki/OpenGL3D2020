[OpenGL 3D 2020 第13回]

# ゾンビ・ストランディング

## 習得目標

* 
* 
* 

## 1. 

### 1.1  

現在、プリミティブやシェーダ、サンプラといった**グラフィックスパイプラインに関わるデータ**は、シーンごとに新しく作成しています。

しかし、これらは全てのシーンで流用できるものがほとんどです。そこで、流用できるデータを独立したクラスに分離します。そして、全てのシーンがそのクラスのデータを使うようにしていきます。

ゲーム全体で使うデータなので、クラス名は`GameData`(ゲームデータ)としましょう。ソリューションエクスプローラーの`ソースファイル`を右クリックして「追加→新しい項目」を選択してください。そして、プロジェクトの`Src`フォルダに`GameData.h`というヘッダファイルを追加します。

追加した`GameData.h`を開き、まずはヘッダファイルをインクルードします。`GameData.h`に次のプログラムを追加してください。

```diff
+/**
+* @file GameData.h
+*/
+#ifndef GAMEDATA_H_INCLUDED
+#define GAMEDATA_H_INCLUDED
+#include "glad/glad.h"
+#include "Shader.h"
+#include "Mesh.h"
+#include "Texture.h"
+#include <GLFW/glfw3.h>
+#include <memory>
+#include <random>
+
+#endif // GAMEDATA_H_INCLUDED
```

これから作る`GameData`クラスには描画用のデータはだいたい全部関係するので、多くのヘッダファイルをインクルードする必要があります。

続いて、`GameData`クラスを定義します。`random`ヘッダのインクルード文の下に、次のプログラムを追加してください。

```diff
 #include <memory>
 #include <random>
+
+/**
+* ゲーム全体で使うデータ.
+*/
+class GameData
+{
+public:
+  // メンバ関数.
+  static GameData& Get();
+  bool Initialize(GLFWwindow*);
+
+  // 描画用のメンバ変数.
+  std::shared_ptr<Shader::Pipeline> pipeline3D;
+  std::shared_ptr<Shader::Pipeline> pipeline2D;
+  Mesh::PrimitiveBuffer primitiveBuffer;
+  Texture::Sampler sampler;
+
+  // 乱数生成用のメンバ変数.
+  std::mt19937 random;
+
+  // GLFWの機能を使うときに使う変数のコピー.
+  GLFWwindow* window = nullptr;
+
+private:
+  // 勝手にクラスの変数を作れないように、コンストラクタとデストラクタをprivateメンバにする.
+  GameData() = default;
+  ~GameData();
+
+  // クラスの変数をコピーできなくするため、コピーコンストラクタとコピー代入演算子をdelete指定する.
+  GameData(const GameData&) = delete;
+  GameData& operator=(const GameData&) = delete;
+};

 #endif // GAMEDATA_H_INCLUDED
```

作成した`GameData`クラスには、これまで作ってきたクラスとは違う部分があります。それは、

<strong>コンストラクタとデストラクタがプライベート指定されている</strong>

ことです。

コンストラクタをプライベートに指定すると、クラスの外側ではそのクラスの変数を作ることができなくなります。デストラクタをプライベートに指定すると、クラスの外側ではそのクラスの変数を破棄することができなくなります。

その結果、クラスのメンバ変数の中ではクラスの変数を作ったり破棄できますが、通常の関数では作ったり破棄できなくなります。もちろん、メンバ関数を実行するためには、そのクラスの変数が必要です。

「メンバ関数でなくてはクラスの変数を作れない」のに、「クラスの変数がなくてはメンバ関数を実行できない」…。これでは堂々巡りで、クラスの変数を作ることはできないように思えます。

この問題は「スタティックメンバ関数」を使えば解決できます。

### 1.2 スタティックメンバ関数

メンバ関数の先頭に`static`キーワードを付けると、そのメンバ関数は「スタティックメンバ関数」になります。

スタティックメンバ関数の特徴は「クラスの変数がなくても実行できる」ことです。つまり、スタティックメンバ関数ならば「クラスの変数がなくてはメンバ関数を実行できない」という問題を回避できるわけです。

`GameData`クラスの場合、`Get`メンバ関数をスタティックメンバ関数にしています。`Get`メンバ関数がどうやってクラスの変数を作り、利用するのか？　それを解明するために、プロジェクトの`Src`フォルダに`GameData.cpp`というファイルを追加してください。

追加した`GameData.cpp`を開き、次のプログラムを追加してください。

```diff
+/**
+* @file GameData.cpp
+*/
+#include "GameData.h"
+#include <iostream>
+
+/**
+* GameDataクラスのシングルトン変数を取得する.
+*
+* @return GameDataクラスのシングルトン変数.
+*/
+GameData& GameData::Get()
+{
+  static GameData singleton;
+  return singleton;
+}
```

`Get`メンバ関数は、関数の中で`GameData`クラスのスタティック変数を定義しています。`Get`はメンバ関数なので、プライベートなメンバ関数を使うことができるのです。

そして、定義したスタティックローカル変数の参照を返します。ここでも`static`が登場しています。ローカル変数に`static`を付けると、そのローカル変数はプログラム全体でひとつだけ定義され、関数が終了しても消えることはありません。

スタティックメンバ関数は「クラスの変数がなくても使える」という効果、スタティックローカル変数は「関数が終了しても使える」という効果があるわけです。

なお、`static`を付けるのは「宣言」だけです。「定義」には付けられないので注意してください。

>**【キーワードには複数の意味がある】**<br>
>C++言語には`static`キーワードのように、使う場所によって異なる意味を持つキーワードがいくつか存在します。<br>
>代表的なのは`const`、`default`、`using`といったキーワードです。他には、`public`、`protected`、`private`も、「メンバの可視性」と「継承の関係性」という2つの用途で使われます。

### 1.3 シングルトン

`GameData`クラスが勝手にクラスの変数を作れないようにしているのは、`GameData`クラスの変数がいくつも作れてしまうとバグの元になるからです。

今後、イベントのクリア状態などを`GameData`クラスに追加していく予定です。うっかり`GameData`クラスの変数を複数作ってしまったら、変数ごとにイベントのクリア状態が異なってしまいます。

この問題を避けるには、クラスの変数がひとつしか存在しないようにするのが確実です。そのため、`GameData`クラスはコンストラクタとデストラクタをプライベート指定して、`Get`スタティックメンバ関数を通じて唯一の変数を参照するようにしているわけです。

このように、書き方の工夫によって、変数がプログラム全体でひとつだけしか存在しないことを保証することを「シングルトン」と言います。また、この仕組みを備えたクラスを「シングルトンクラス」と言います。

>**【シングルトンの意味】**<br>
>「シングルトン(`singleton`)」は、「単一の人や物」を表す英単語で、「ひとつ」を意味する「シングル(`single`)」に、「ひとかたまりのもの」を表す接尾辞「トン(`-ton`)」を付けたものです。

### 1.4 Initializeメンバ関数を定義する

続いて`Initialize`(イニシャライズ)メンバ関数を定義します。`Get`メンバ関数の定義の下に、次のプログラムを追加してください。

```diff
   static GameData singleton;
   return singleton;
 }
+
+/**
+* ゲームデータを初期化する.
+*
+* @param window GLFWウィンドウへのポインタ.
+*
+* @retval true  初期化成功.
+* @retval false 初期化失敗.
+*/
+bool GameData::Initialize(GLFWwindow* window)
+{
+  std::cout << "[情報] ゲームデータの初期化を開始.\n";
+
+  // プリミティブバッファにモデルデータを読み込む.
+  if (!primitiveBuffer.Allocate(100'000, 400'000)) {
+    return false;
+  }
+  primitiveBuffer.AddFromObjFile("Res/Ground.obj");
+  primitiveBuffer.AddFromObjFile("Res/Tree.obj");
+  primitiveBuffer.AddFromObjFile("Res/House.obj");
+  primitiveBuffer.AddFromObjFile("Res/Cube.obj");
+  primitiveBuffer.AddFromObjFile("Res/Plane.obj");
+  primitiveBuffer.AddFromObjFile("Res/Bullet.obj");
+  primitiveBuffer.AddFromObjFile("Res/zombie_male_walk_0.obj");
+  primitiveBuffer.AddFromObjFile("Res/zombie_male_walk_1.obj");
+  primitiveBuffer.AddFromObjFile("Res/zombie_male_walk_2.obj");
+  primitiveBuffer.AddFromObjFile("Res/zombie_male_walk_3.obj");
+  primitiveBuffer.AddFromObjFile("Res/zombie_male_walk_4.obj");
+  primitiveBuffer.AddFromObjFile("Res/zombie_male_walk_5.obj");
+  primitiveBuffer.AddFromObjFile("Res/zombie_male_down_0.obj");
+  primitiveBuffer.AddFromObjFile("Res/zombie_male_down_1.obj");
+  primitiveBuffer.AddFromObjFile("Res/zombie_male_down_2.obj");
+  primitiveBuffer.AddFromObjFile("Res/zombie_male_down_3.obj");
+  primitiveBuffer.AddFromObjFile("Res/player_male_idle_0.obj");
+
+  // パイプライン・オブジェクトを作成する.
+  pipeline3D = std::make_shared<Shader::Pipeline>("Res/FragmentLighting.vert", "Res/FragmentLighting.frag");
+  if (!pipeline3D || !*pipeline3D) {
+    return false;
+  }
+  pipeline2D = std::make_shared<Shader::Pipeline>("Res/Simple.vert", "Res/Simple.frag");
+  if (!pipeline2D || !*pipeline2D) {
+    return false;
+  }
+
+  // サンプラ・オブジェクトを作成する.
+  sampler.SetWrapMode(GL_REPEAT);
+  sampler.SetFilter(GL_LINEAR);
+
+  // ゲームデータ経由で使えるようにウィンドウ変数を保存.
+  this->window = window;
+
+  // 乱数を初期化.
+  random.seed(std::random_device{}());
+
+  std::cout << "[情報] ゲームデータの初期化を完了.\n";
+  return true;
+}
```

### 1.5 プリミティブ番号を移植する

プリミティブの管理には列挙型を使います。`MainGameScene`クラスの`PrimNo`をコピーして、`GameData.h`の`GameData`クラス定義に貼り付けてください。

```diff
   // メンバ関数.
   static GameData& Get();
   bool Initialize(GLFWwindow*);
+
+  // プリミティブ番号.
+  // プリミティブの読み込み順と一致させること.
+  enum PrimNo {
+    ground,
+    tree,
+    house,
+    cube,
+    plane,
+    zombie_male_walk_0,
+    zombie_male_walk_1,
+    zombie_male_walk_2,
+    zombie_male_walk_3,
+    zombie_male_walk_4,
+    zombie_male_walk_5,
+    zombie_male_down_0,
+    zombie_male_down_1,
+    zombie_male_down_2,
+    zombie_male_down_3,
+    player_idle_0,
+    bullet,
+  };

   // 描画用のメンバ変数.
   std::shared_ptr<Shader::Pipeline> pipeline3D;
   std::shared_ptr<Shader::Pipeline> pipeline2D;
```

### 1.6 デストラクタを定義する

最後にテストラクタを定義します。`Initialize`メンバ関数の定義の下に、次のプログラムを追加してください。

```diff
   std::cout << "[情報] ゲームデータの初期化を完了.\n";
   return true;
 }
+
+/**
+* デストラクタ.
+*/
+GameData::~GameData()
+{
+  std::cout << "[情報] ゲームデータを破棄.\n";
+}
```

デストラクタでは、デバッグ用にゲームデータが破棄されたことを出力します。

これで`GameData`クラスは完成です。

>**【基本は参照を使い、ポインタ操作が必要な場合だけポインタを使う】**<br>
>C言語では、GameDataクラスのように関数を通じて変数を取得する場合、戻り値は「ポインタ」を使います。<br>
>しかしC++言語では、多くの場合に「参照」を使います。なぜなら、「ポインタより参照のほうが、できる操作が少ない」からです。<br>
>できる操作が少なければ、プログラムを書くときに考えなければならないことも少なくなります。その結果、読みやすく、書きやすく、さらにエラーの起きにくいプログラムが作れるのです。

<div style="page-break-after: always"></div>

## 2. GameDataクラスを使う

1. GameDataで既存の描画処理を置き換える
1. プレイヤーアニメーション設定.
1. GameDataに「倒したゾンビの数」カウンタを追加し、ソンビ死亡時にインクリメント.
1. 倒したゾンビの数が100になったらクリア画像を表示.
1. クリア画像表示中にEnterが押されたらエンディング画面に遷移.
1. エンディング画面でEnterが押されたらタイトル画面に遷移.
1. 連射速度を遅くする.




### 2.1 GameDataを初期化する

`GameData`を使って既存の描画用変数を置き換えていきましょう。これは以下の手順で行います。

1. `GameData`を初期化する.
2. タイトル画面のヘッダファイルから、描画用の変数を削除する。
3. タイトル画面のCPPファイルに`GameData.h`をインクルードする。
4. タイトル画面のエラーになっている箇所を、`GameData`クラスの変数で置き換える。
5. メインゲーム画面のヘッダファイルから、描画用の変数を削除する。
6. メインゲーム画面のCPPファイルに`GameData.h`をインクルードする。
7. メインゲーム画面のエラーになっている箇所を、`GameData`クラスの変数で置き換える。

とにかく、`GameData`クラスの変数を初期化しないことには話が進みません。全てのシーンで使う変数なので、最初のシーンの起動より前に初期化しておく必要があります。

`Main.cpp`を開き、次のプログラムを追加してください。

```diff
   glDebugMessageCallback(DebugCallback, nullptr);
+
+  // ゲーム全体で使うデータを初期化する.
+  GameData& gameData = GameData::Get();
+  if (!gameData.Initialize(window)) {
+    return 1;
+  }

   // 最初に実行するシーンを指定する.
   SceneManager& sceneManager = SceneManager::Get();
   sceneManager.ChangeScene(SCENENAME_TITLE);
```

### 2.2 タイトル画面の描画用変数を削除する

まずタイトル画面から手を付けていきます。削除するのは`GameData`クラスに定義した`PrimitiveBuffer`、`Sampler`、`Pipeline`の3つです。`TitleScene.h`を開き、`TitleScene`クラスの定義から描画用のメンバ変数を削除してください。

```diff
   void Finalize();

 private:
-  Mesh::PrimitiveBuffer primitiveBuffer;
-  Texture::Sampler sampler;
-  std::shared_ptr<Shader::Pipeline> pipeline;
-
   std::shared_ptr<Texture::Image2D> texLogo;
   std::shared_ptr<Texture::Image2D> texPressEnter;
```

削除したメンバ変数の役割は、`GameData`クラスの変数が引きつぐことになります。

### 2.3 タイトル画面のCPPファイルにGameData.hをインクルードする

次に`GameData.h`をインクルードします。`TitleScene.cpp`を開き、次のプログラムを追加してください。

```diff
 * @file TitleScene.cpp
 */
 #include "TitleScene.h"
+#include "GameData.h"
 #include <glm/gtc/matrix_transform.hpp>
 #include <iostream>
```

これで`TitleScene.cpp`の中で`GameData`クラスの変数が使えるようになりました。

### 2.4 タイトル画面のエラーになっている箇所をGameDataクラスの変数で置き換える

続いて、`Initialize`メンバ関数から、削除した変数を初期化するプログラムを消去します。`Initialize`メンバ関数を次のように変更してください。

```diff
 bool TitleScene::Initialize()
 {
-  // プリミティブバッファにモデルデータを読み込む.
-  if (!primitiveBuffer.Allocate(20'000, 80'000)) {
-    return false;
-  }
-  primitiveBuffer.AddFromObjFile("Res/Plane.obj");
-
-  // パイプライン・オブジェクトを作成する.
-  pipeline = std::make_shared<Shader::Pipeline>(
-    "Res/Simple.vert", "Res/Simple.frag");
-  if (!pipeline) {
-    return false;
-  }
-
-  // サンプラ・オブジェクトを作成する.
-  sampler.SetWrapMode(GL_CLAMP_TO_EDGE);
-  sampler.SetFilter(GL_LINEAR);
-
   // テクスチャを読み込む.
   texLogo = std::make_shared<Texture::Image2D>("Res/TitleLogo.tga");
```

そして、`Render`メンバ関数を`GameData`クラスを使うように変更します。`Render`メンバ関数に次のプログラムを追加してください。

```diff
   const glm::mat4 matView =
     glm::lookAt(glm::vec3(0, 0, 100), glm::vec3(0), glm::vec3(0, 1, 0));
+
+  // ゲームデータ変数を取得.
+  GameData& gameData = GameData::Get();
+  PrimitiveBuffer& primitiveBuffer = gameData.primitiveBuffer;
+  std::shared_ptr<Shader::Pipeline> pipeline = gameData.pipeline2D;
+  Shader::Sampler& sampler = gameData.sampler;

   primitiveBuffer.BindVertexArray(); // VAOをバインド.
   pipeline->Bind(); // パイプラインをバインド.
   sampler.Bind(0); // サンプラをバインド.
```

ただ、元々タイトル画面で最初に読み込んでいた`Plane.obj`は、`GameData`クラスでは`4`番目のプリミティブに当たります。そのため、このままでは画像の表示がおかしくなってしまいます。

そこで、プリミティブ番号を適切な値に変更しましょう。`Render`メンバ関数の画像描画プログラムを、次のように修正してください。

```diff
     const glm::mat4 matMVP = matProj * matView * matModelT * matModelS;
     pipeline->SetMVP(matMVP);
     texLogo->Bind(0);
-    primitiveBuffer.Get(0).Draw();
+    primitiveBuffer.Get(GameData::PrimNo::plane).Draw();
   }

   // PressEnterを描画.
   {
     const glm::mat4 matModelT = glm::translate(glm::mat4(1), glm::vec3(0, -200, 0));
     const glm::mat4 matModelS =
       glm::scale(glm::mat4(1), glm::vec3(texPressEnter->Width(), texPressEnter->Height(), 1));
     const glm::mat4 matMVP = matProj * matView * matModelT * matModelS;
     pipeline->SetMVP(matMVP);
     texPressEnter->Bind(0);
-    primitiveBuffer.Get(0).Draw();
+    primitiveBuffer.Get(GameData::PrimNo::plane).Draw();
   }
```

これでタイトル画面は`GameData`クラスを使って表示されるようになります。プログラムが書けたらビルドして実行してください。問題なくタイトル画面が表示されたら成功です。

### 2.5 メインゲーム画面の描画用の変数を削除する

タイトル画面と同じ要領で、メインゲーム画面の描画用メンバ変数も`GameData`クラスの変数に置き換えましょう。タイトル画面と同様に、`PrimitiveBuffer`、`Sampler`、`Pipeline`の3つを削除します。`MainGameScene.h`を開き、`MainGameScene`クラスを次のように変更してください。

```diff
   void Finalize();

 private:
-  Mesh::PrimitiveBuffer primitiveBuffer;
-  Texture::Sampler sampler;
-  std::shared_ptr<Shader::Pipeline> pipeline;
   std::shared_ptr<Texture::Image2D> texGround;
   std::shared_ptr<Texture::Image2D> texTree;
   std::shared_ptr<Texture::Image2D> texHouse;
```

### 2.6 メインゲーム画面のCPPファイルにGameData.hをインクルードする

`MainGameScene.cpp`を開き、次のように`GameData.h`をインクルードしてください。

```diff
 * @file MainGameScene.cpp
 */
 #include "MainGameScene.h"
+#include "GameData.h"
 #include <glm/gtc/matrix_transform.hpp>
 #include <iostream>
 #include <random>
```

### 2.7 メインゲーム画面のエラーになっている箇所をGameDataクラスの変数で置き換える

`Initialize`メンバ関数から、削除したメンバ変数に関する行を消していきます。

```diff
 bool MainGameScene::Initialize()
 {
-  if (!primitiveBuffer.Allocate(20'000, 80'000)) {
-    return 1;
-  }
-  primitiveBuffer.Add(std::size(posGround), posGround, colGround, tcGround,
-    std::size(indexGround), indexGround);
-  primitiveBuffer.AddFromObjFile("Res/Ground.obj");
-  primitiveBuffer.AddFromObjFile("Res/Tree.obj");
-  primitiveBuffer.AddFromObjFile("Res/House.obj");
-  primitiveBuffer.AddFromObjFile("Res/Cube.obj");
-  primitiveBuffer.AddFromObjFile("Res/zombie_male_walk_0.obj");
-  primitiveBuffer.AddFromObjFile("Res/zombie_male_walk_1.obj");
-  primitiveBuffer.AddFromObjFile("Res/zombie_male_walk_2.obj");
-  primitiveBuffer.AddFromObjFile("Res/zombie_male_walk_3.obj");
-  primitiveBuffer.AddFromObjFile("Res/zombie_male_walk_4.obj");
-  primitiveBuffer.AddFromObjFile("Res/zombie_male_walk_5.obj");
-  primitiveBuffer.AddFromObjFile("Res/zombie_male_down_0.obj");
-  primitiveBuffer.AddFromObjFile("Res/zombie_male_down_1.obj");
-  primitiveBuffer.AddFromObjFile("Res/zombie_male_down_2.obj");
-  primitiveBuffer.AddFromObjFile("Res/zombie_male_down_3.obj");
-  primitiveBuffer.AddFromObjFile("Res/player_male_idle_0.obj");
-  primitiveBuffer.AddFromObjFile("Res/Bullet.obj");
-
-  // パイプライン・オブジェクトを作成する.
-  pipeline = std::make_shared<Shader::Pipeline>(
-    "Res/FragmentLighting.vert", "Res/FragmentLighting.frag");
-  if (!pipeline) {
-    return 1;
-  }
-  // サンプラ・オブジェクトを作成する.
-  Texture::Sampler sampler;
-  if (!sampler) {
-    return 1;
-  }
-  sampler.SetWrapMode(GL_REPEAT);
-  sampler.SetFilter(GL_NEAREST);

   const GLuint texGround =
     GLContext::CreateImage2D(imageWidth, imageHeight, imageGround);
```

次に、`Render`メンバ関数を`GameData`クラスを使うように変更します。`Render`メンバ関数に次のプログラムを追加してください。

```diff
   const glm::mat4 matView =
     glm::lookAt(viewPosition, viewTarget, glm::vec3(0, 1, 0));
+
+  // ゲームデータ変数を取得.
+  GameData& gameData = GameData::Get();
+  PrimitiveBuffer& primitiveBuffer = gameData.primitiveBuffer;
+  std::shared_ptr<Shader::Pipeline> pipeline = gameData.pipeline2D;
+  Shader::Sampler& sampler = gameData.sampler;

   primitiveBuffer.BindVertexArray();
   pipeline.Bind();
   sammpler.Bind(0);
```

### 2.8 PrimNoをGameData::PrimNoで置き換える

`MainGameScene`クラスにもプリミティブ番号は定義していますが、`GameData`のプリミティブ番号とは一致しません。

そこで、まず`MainGameScene`クラスから`PrimNo`を削除します。そして、エラーが起きている部分を`GameData::PrimNo`で置き換えます。`MainGameScene.h`を開き、`MainGameScene`クラスの`PrimNo`列挙型を削除してください。

```diff
   ActorList actors; // アクター配列.
   ActorPtr playerActor; // プレイヤーアクター.
-
-  // プリミティブ番号.
-  // プリミティブの読み込み順と一致させること.
-  enum PrimNo {
-    ground,
-    tree,
-    house,
-    cube,
-    zombie_male_walk_0,
-    zombie_male_walk_1,
-    zombie_male_walk_2,
-    zombie_male_walk_3,
-    zombie_male_walk_4,
-    zombie_male_walk_5,
-    zombie_male_down_0,
-    zombie_male_down_1,
-    zombie_male_down_2,
-    zombie_male_down_3,
-    player_idle_0,
-    bullet,
-  };
 };
```

`PrimNo`列挙型を削除したら、次はCPPファイルの`PrimNo`を`GameData::PrimNo`で置き換えていきます。`MainGameScene.cpp`を開き、`Intialize`メンバ関数のプレイヤーのプリミティブ番号を、次のように変更してください。

```diff
   // プレイヤーアクターを作成.
   playerActor = std::make_shared<Actor>(
-    &primitiveBuffer.Get(PrimNo::player_idle_0),
+    &primitiveBuffer.Get(GameData::PrimNo::player_idle_0),
     texPlayer, glm::vec3(10, 0, 10));
   // 作成したプレイヤーアクターを、アクターリストに追加.
   actors.push_back(player);
```

<pre class="tnmai_assignment">
<strong>【課題01】</strong>
残りの<code>PrimNo</code>を<code>GameData::PrimNo</code>で置き換えなさい。
</pre>

課題01が完了したら、ビルドして実行してください。問題なくメインゲーム画面が動作したら成功です。







