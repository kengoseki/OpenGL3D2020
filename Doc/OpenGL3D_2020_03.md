[OpenGL 3D 2020 第03回]

# インデックス・レコード

## 習得目標

* インデックス・バッファの使い方
* さまざまな座標系の違い
* 複数のモデルを表示する方法

## 1. インデックス・バッファ

### 1.1 不必要に頂点データを増やさない方法

OpenGLが描画できるプリミティブには四角形がありません。四角形を表示するには、 `GL_TRIANGLES`や`GL_TRIANGLE_STRIP`、`GL_TRIANGLE_FAN`のいずれかを使って2つの三角形を組み合わせます。どれを使ってもよさそうに思えますが、複数の四角形を表示するときに違いが出てきます。

`GL_TRIANGLES`は好きな位置に図形を作れるので、`glDrrawArrays`呼び出しは1回で十分です。しかし、`GL_TRIANGLE_STRIP`、`GL_TRIANGLE_FAN`では四角形の数だけ呼び出さなければなりません。個々で問題になるのが、`glDrawArrays`の実行にかかる時間です。

`glDrawArrays`はGPUの状態設定などを行うため、OpenGLの関数のなかでも時間のかかるほうです。また、この状態設定にかかる時間は、描画する図形の数とは無関係です。そのため、同じ数の図形を描画するなら、この関数の実行回数が少ないほうが、GPUの処理時間に余裕ができます。そういうわけで、一般的には`GL_TRIANGLES`が使われます。

ただし、`GL_TRIANGLES`を使う場合、ひとつの四角形につき頂点データが合計6つ必要です。図形としては角がひとつ増えただけなのに、頂点データは3つも追加しなければならないのです。頂点データが増えると、それだけメモリが必要です。また、頂点データの数だけシェーダーが実行されるため、処理時間も増えます。

<div style="text-align: center;width: 100%;">
<img src="images/03_rectangle_by_triangles.png" style="width:40%; margin-left:auto; margin-right:auto"/>
</div>

`glDrawArrays`を使って描画する限り、`GL_TRIANGLES`は他の形式より多くの頂点を用意せざるをえません。これが、過去に`GL_TRIANGLES`が日の目を見なかった原因です。しかし、現在は猫も<ruby>杓子<rt>しゃくし</rt></ruby>も`GL_TRIANGLES`を使っています。なぜなら、近代的なGPUは、必要最小限の頂点データを用意するだけで図形を描画できるからです。

その<ruby>要<rt>かなめ</rt></ruby>となるのが「インデックス・バッファ」です。インデックスバッファを使えば、頂点データを直接プリミティブとして扱うのではなく、「頂点の番号」によって間接的に扱うことが可能になります。

もちろん、インデックスバッファもメモリを使います。しかし、格納されるのは「頂点の番号」だけなので、せいぜい`GLint`型変数ひとつ、容量にして4バイトです。それに比べて頂点データは、座標だけでも3つの`float`を使うので12バイトとなります。これはインデックスデータの3倍の容量です。実際の頂点データには色や法線など他の情報も存在するので、その差はさらに広がります。

そして、近代的なGPUには、「既にシェーダーを実行済みの頂点番号が指定されたときは、前の実行結果を使い回す」、という機能が搭載されています。この機能のおかげで、シェーダーの実行回数は必要最小限に抑えられます。

>**【補足】**<br>
`GL_TRIANGLE_STRIP`については、頂点データを工夫すれば複数の四角形を一回の `glDrawArrays`で表示できます。しかし、これには画面に映らない余分な頂点データが必要となるので、メモリを節約するという目的は果たせません。

### 1.2 インデックス・データ

インデックス・バッファの使い方を確認するために、頂点データ配列に4つの頂点を追加しましょう。`positions`と`colors`の先頭に、次のプログラムを追加してください。なお、過去の課題をクリアした結果、テキストに書かれているプログラムとは違っている部分はそのままで構いません。以降のプログラムも同様です。

```diff
 /// 座標データ.
 const Position positions[] = {
+  {-0.3f, -0.3f, 0.5f},
+  { 0.2f, -0.3f, 0.5f},
+  { 0.2f,  0.5f, 0.5f},
+  {-0.3f,  0.5f, 0.5f},
+
   {-0.33f, 0.5f, 0.5f},
   { 0.33f, 0.5f, 0.5f},
   { 0.0f,  -0.5f, 0.5f},
```

<br>

```diff
 /// 色データ.
 const Color colors[] = {
+  {0.0f, 1.0f, 0.0f, 1.0f},
+  {0.0f, 0.0f, 1.0f, 1.0f},
+  {1.0f, 0.0f, 0.0f, 1.0f},
+  {0.0f, 0.0f, 1.0f, 1.0f},
+
   {0.0f, 1.0f, 1.0f, 1.0f}, // 水色
   {1.0f, 1.0f, 0.0f, 1.0f}, // 黄色
   {1.0f, 0.0f, 1.0f, 1.0f}, // 紫色
```

追加した頂点データは、左下を始点として反時計回りに4つの頂点を定義しています。

次に、インデックスデータを追加しましょう。色データ配列の定義の下に、次のプログラムを追加してください。

```diff
   {0.0f, 0.0f, 0.0f, 1.0f},
   {1.0f, 1.0f, 1.0f, 1.0f},
 };
+
+// インデックスデータ.
+const GLushort indices[] = {
+  0, 1, 2, 2, 3, 0,
+};

 /// 頂点シェーダー.
 static const GLchar* const vsCode =
```

インデックスデータは「頂点データ配列の先頭から何番目の頂点データか」を示す数値の集まりです。頂点データがそうであるように、インデックスデータもプリミティブの指定と組み合わせてはじめて実際の形状が確定します。

今回作成した`indices`(インディシーズ、indexの複数形)配列変数の場合、`GL_TRIANGLES`を使って描画する前提で「0, 1, 2」と[2, 3, 0」という2つの三角形を定義しています。`0`と`2`が2回ずつ使われているのが分かりますね。これは、2つの三角形の間で`0`番と`2`番の頂点が「<ruby>共有<rt>きょうゆう</rt></ruby>」されていることを意味します。

インデックスデータの型は以下の3つから選択できます。

|型|ビット数|表せる範囲|
|:-:|:-:|:--|
|GLubyte(ジーエル・ユー・バイト)|8|0～255|
|GLushort(ジーエル・ユー・ショート)|16|0～65535|
|GLuint(ジーエル・ユー・イント)|32|0～4294967295|

ビット数の大きい型のほうが多くの頂点データを扱うことができますが、インデックスデータのサイズが大きくなります。今回はそれほど大きな頂点データを扱うつもりはありませんので、16bitの`GLushort`で十分だと判断しました。

### 1.3 Index Buffer Object(IBO)の作成

頂点データを格納するときに「Vertex Buffer Object(VBO)」というオブジェクトを作りましたね。同様に、インデックスデータを格納するには「Index Buffer Object(インデックス・バッファ・オブジェクト、IBO)」というオブジェクトを使います。

といっても、`IBO`の作り方は`VBO`と全く同じです。ですから、`CreateBuffer`関数で作ることができます。`VAO`を作成するプログラムに次のプログラムを追加してください。

```diff
   // VAOを作成する.
   const GLuint positionBuffer = GLContext::CreateBuffer(sizeof(positions), positions);
   const GLuint colorBuffer = GLContext::CreateBuffer(sizeof(colors), colors);
+  const GLuint ibo = GLContext::CreateBuffer(sizeof(indices), indices);
   const GLuint vao = GLContext::CreateVertexArray(positionBuffer, colorBuffer);
   if (!vao) {
```

不要になったら後始末をしなければなりません。後始末をするプログラムに、次のプログラムを追加してください。

```diff
   // 後始末.
   glDeleteProgramPipelines(1, &pipeline);
   glDeleteProgram(fp);
   glDeleteProgram(vp);
   glDeleteVertexArrays(1, &vao);
+  glDeleteBuffers(1, &ibo);
   glDeleteBuffers(1, &colorBuffer);
   glDeleteBuffers(1, &positionBuffer);
```

### 1.4 IBOをVAOに関連付ける

`VBO`と同様に`IBO`もVAOに設定しなければなりません。そこで、`CreateVertexArray`関数の引数に`IBO`を追加することにします。`GLContext.h`を開き、`CreateVertexArray`関数の宣言を次のように修正してください。

```diff
 namespace GLContext {

 GLuint CreateBuffer(GLsizeiptr size, const GLvoid* data);
-GLuint CreateVertexArray(GLuint vboPosition, GLuint vboColor);
+GLuint CreateVertexArray(GLuint vboPosition, GLuint vboColor, GLuint ibo);
 GLuint CreateProgram(GLenum type, const GLchar* code);
 GLuint CreatePipeline(GLuint vp, GLuint fp);
```

続いて、`GLContext.cpp`を開き、`CreateVertexArray`関数の引数にインデックスバッファを加えてください。

```diff
 * @param vboPosition VAOに関連付けられる座標データ.
 * @param vboColor    VAOに関連付けられるカラーデータ.
+* @param ibo         VAOに関連付けられるインデックスデータ.
 *
 * @return 作成したVAO.
 */
-GLuint CreateVertexArray(GLuint vboPosition, GLuint vboColor)
+GLuint CreateVertexArray(GLuint vboPosition, GLuint vboColor, GLuint ibo)
 {
-  if (!vboPosition || !vboColor) {
+  if (!vboPosition || !vboColor || !ibo) {
     return 0;
   }
```

インデックスバッファを`VAO`に設定するには`glVertexArrayElementBuffer`(ジーエル・バーテックス・アレイ・エレメント・バッファ)関数を使います。`CreateVertexArray`関数に次のプログラムを追加してください。

```diff
   glVertexArrayAttribBinding(id, colorIndex, colorBindingIndex);
   glVertexArrayVertexBuffer(id, colorBindingIndex, vboColor, 0, sizeof(Color));
+
+  glVertexArrayElementBuffer(id, ibo);

   return id;
 }
```

<p><code class="tnmai_code"><strong>【書式】</strong><br>
glVertexArrayElementBuffer(VAOのID, IBOのID);
</code></p>

この関数を呼ぶと`VAO`に`IBO`が割り当てられ、`IBO`を使ったプリミティブの描画ができるようになります。

続いて、`CreateVertexArray`関数の呼び出しを修正しましょう。`Main.cpp`を開き、`VAO`を作成するプログラムを次のように修正してください。

```diff
   const GLuint positionBuffer = GLContext::CreateBuffer(sizeof(positions), positions);
   const GLuint colorBuffer = GLContext::CreateBuffer(sizeof(colors), colors);
   const GLuint ibo = GLContext::CreateBuffer(sizeof(indices), indices);
-  const GLuint vao = GLContext::CreateVertexArray(positionBuffer, colorBuffer);
+  const GLuint vao = GLContext::CreateVertexArray(positionBuffer, colorBuffer, ibo);
   if (!vao) {
     return 1;
   }
```

これで`VAO`に`IBO`が設定されました。

### 1.5 インデックスデータを使った描画

最後に描画関数を変更します。頂点データの場合は`glDrawArrays`関数を使いますが、インデックスデータでは`glDrawElements`(ジーエル・ドロー・エレメンツ)関数が使われます。そういうことなので、メインループのコードを次のように変更してください。

```diff
     glBindVertexArray(vao);
     glBindProgramPipeline(pipeline);

-    glDrawArrays(GL_TRIANGLES, 0, sizeof(positions)/sizeof(positions[0]));
+    glDrawElements(
+      GL_TRIANGLES, sizeof(indices)/sizeof(indices[0]), GL_UNSIGNED_SHORT, 0);

     glBindProgramPileline(0);
     glBindVertexArray(0);
```

`glDrawElements`関数の書式は次のとおりです。

<p><code class="tnmai_code"><strong>【書式】</strong><br>
glDrawElements(プリミティブの種類, 描画するインデックスの数,<br>
&emsp;インデックスの型, インデックスデータの位置);
</code></p>

参考までに、`glDrawArrays`関数の書式も挙げておきます。

<p><code class="tnmai_code"><strong>【書式】</strong><br>
glDrawArrays(プリミティブの種類, 頂点データの位置, 描画する頂点の数);
</code></p>

こうして比べてみると、頂点とインデックスの違いはあっても、2つの関数がとてもよく似ていることが分かりますね。そして、一番の違いは`glDrawElements`には「インデックスの型」という引数があることでしょう。

頂点データの場合、データ構造は`VAO`を作成するときに同時に定義していました。しかし、インデックスデータには頂点データのような複雑な構造はなく、ひとつの型があるだけです。その程度ならわざわざ`VAO`に設定する必要はありませんので、引数で指定する形になっているのです。

「インデックスの型」は以下の3つから指定します。

|インデックスの型|対応する定数名|
|:-:|:--|
|GLubyte|GL_UNSIGNED_BYTE(ジーエル・アンサインド・バイト)|
|GLushort|GL_UNSIGNED_SHORT(ジーエル・アンサインド・ショート)|
|GLuint|GL_UNSIGNED_INT(ジーエル・アンサインド・イント)|

`indices`変数は`GLushort`型なので、`GL_UNSIGNED_SHORT`を指定しています。

>**【補足】** `unsigned`(アンサインド)は「符号のない、無符号の」という意味です。

「インデックスデータの位置」は、描画に使うインデックスデータの先頭位置を「インデックスデータの先頭からのバイト数」(バイトオフセットといいます)で指定します。今回は先頭から使うので`0`を指定しています。

プログラムが書けたらビルドして実行してください。次のように四角形がひとつ表示されたら成功です。

<div style="text-align: center;width: 100%;">
<img src="images/03_result_1.png" style="width:50%; margin-left:auto; margin-right:auto"/>
</div>

### 1.6 頂点を共有しないことについて

表示したい図形によっては、2つ以上のポリゴンで頂点を共有すると都合が悪い場合があります。例えば、四角形を追加して、以下の画像のように表示したいとします。

<div style="text-align: center;width: 100%;">
<img src="images/03_result_2.png" style="width:50%; margin-left:auto; margin-right:auto"/>
</div>

追加した四角形は、対角線にそって色が混ざらずに分かれています。このような結果を得るには、ポリゴンごとに異なる色を設定しなければなりません。言葉で説明されても分かりにくいと思いますのでちょっとやってみましょう。まず次のように座標データと色データを追加してください。

```diff
 const Position positions[] = {
   {-0.3f, -0.3f, 0.5f},
   { 0.2f, -0.3f, 0.5f},
   { 0.2f,  0.5f, 0.5f},
   {-0.3f,  0.5f, 0.5f},
+
+  {-0.2f, -0.5f, 0.1f},
+  { 0.3f, -0.5f, 0.1f},
+  { 0.3f,  0.3f, 0.1f},
+  { 0.3f,  0.3f, 0.1f},
+  {-0.2f,  0.3f, 0.1f},
+  {-0.2f, -0.5f, 0.1f},

   {-0.33f, 0.5f, 0.5f},
   { 0.33f, 0.5f, 0.5f},
```

```diff
 const Color colors[] = {
   {0.0f, 1.0f, 0.0f, 1.0f},
   {0.0f, 0.0f, 1.0f, 1.0f},
   {1.0f, 0.0f, 0.0f, 1.0f},
   {0.0f, 0.0f, 1.0f, 1.0f},
+
+  {1.0f, 0.0f, 0.0f, 1.0f},
+  {1.0f, 1.0f, 0.0f, 1.0f},
+  {1.0f, 0.0f, 0.0f, 1.0f},
+  {0.0f, 0.0f, 1.0f, 1.0f},
+  {0.0f, 1.0f, 1.0f, 1.0f},
+  {0.0f, 0.0f, 1.0f, 1.0f},

   {0.0f, 1.0f, 1.0f, 1.0f},
   {1.0f, 1.0f, 0.0f, 1.0f},
```

続いて、次のようにインデックスデータを追加してください。

```diff
 /// インデックスデータ.
 const GLushort indices[] = {
   0, 1, 2, 2, 3, 0,
+  4, 5, 6, 7, 8, 9,
 };
```

四角形をひとつ追加するだけなのですが、頂点データは4個ではなく6個追加されています。それと、追加したインデックスデータに重複する番号がないことに気づいたでしょうか？

プログラムが書けたらビルドして実行してください。先に示した画像のように表示されたら成功です。

OpenGLにおいて、ポリゴン内の各フラグメントの色は、各頂点の色を、頂点からの距離の比率によって混合したものになります。そのため、最初に作った四角形のように複数のポリゴンで頂点を共有している場合、境界線はあまりはっきりとは見えません。これは基本的には望ましい動作です。というのも、現実の物体には、はっきりとした境界のない部分のほうが多いからです。

<div style="text-align: center;width: 100%;">
<img src="images/03_mixing_vertex_colors.png" style="width:60%; margin-left:auto; margin-right:auto"/>
</div>

しかし、時にはポリゴン境界をはっきりとさせたい場合があります。そんなときは、この節で追加した四角形のように、ポリゴンごとに別々の頂点データを割り当てます(頂点を共有しません)。この場合、`glVertexArrays`関数で描画するのと比べると、インデックスデータのぶんだけ余分なメモリが必要になってしまいます。

この節で追加したような小さな図形でインデックスデータを使うことは、デメリットしかありません。しかし、一般的にゲームのキャラクターは数百から数万の頂点を持っています。そのようなデータでは、たとえ一部の頂点が共有できないとしても、全体としては共有される頂点数のほうがはるかに多くなります。ですから、インデックスデータを使うほうが効率的であることに変わりはありません。

>**【インデックスデータを使わないほうがよい場合はあるの？】**<br>
めったに無いことですが、頂点が全くあるいはほとんど共有されない場合は、インデックスデータを使わないほうがよいです。例としては、`GL_POINT`を使った点の描画が挙げられます。

<div style="page-break-after: always"></div>

## 2. 座標系

### 2.1 さまざまな座標系

これまで、頂点データの座標には0.5とか-0.3といった数値を使ってきました。例えば最初の頂点の座標は(-0.5, 0.5, 0.5)です。前回説明したように、これはこの頂点が「ワールド座標系上のX座標-0.5、Y座標0.5、Z座標0.5の位置にある」ことを示しているわけですが、この「ワールド座標系」とは何者なのでしょう？それを知るには、まずOpenGLで使われる座標系について理解しなければなりません。

「座標系」は「座標を定めるためのルール」です。このルールには「原点の位置」、「距離の単位」「軸の数や方向」などが含まれます。コンピューター・グラフィックスでは、用途に応じてさまざまな座標系を使い分けます。OpenGLで使われる座標系を下図に示します。また、座標系はそれぞれ異なる原点と軸を持っています。ある座標系で定義された座標について、異なる座標系で同じ位置を示す座標を得るには、座標変換を行う必要があります。以下の図は、コンピューター・グラフィックスで使われる一般的な座標系とその関係を表しています。

<div style="text-align: center;width: 100%;">
<img src="images/03_hebo_peke_coordinates.png" style="width:80%; margin-left:auto; margin-right:auto"/>
</div>

* **ローカル座標系**<br>
ポリゴンモデルを定義する座標系です。モデル座標系、オブジェクト座標系とも呼ばれます。一般的に、頂点シェーダの入力はこの座標系になります。原点は、モデルの中心か足元とされることが多いです。

* **ワールド座標系**<br>
ポリゴンモデル同士の位置関係を定義する座標系です。原点はシーンの中心とされることが多いです。ローカル座標系からワールド座標系への変換は「モデル変換」または「ワールド変換」と呼ばれます。

* **ビュー座標系**<br>
視点を基準とする座標系です。カメラ座標系、視点(Eye)座標系とも呼ばれます。原点は視点の座標になります。ワールド座標系からビュー座標系への変換は「ビュー変換」と呼ばれます。

* **クリップ座標系**<br>
クリッピングという、画面に映らない部分を除去する処理のための座標系です。頂点シェーダ(テッセレータやジオメトリシェーダも使う場合、そのうちで最後に実行されるシェーダ)から出力される座標は、この座標系て定義されていなければなりません。<br>
クリップ座標系はXYZ各軸が±Wの大きさを持つ空間です(検索すると±1としている文章を見かけると思いますが、概念的には正しい説明です。それでも、ほとんどのグラフィックスハードウェアの実装では±Wとして扱われます)。±Wを超えた位置にあるポリゴンはグラフィックスパイプラインから除去されます。境界にまたがるポリゴンは外側になる部分だけが除去されます。<br>
ローカル座標系、ワールド座標系、ビュー座標系からクリップ座標系への変換は、シェーダで行わなければなりません。この座標系の空間は、座標変換の方法によって立方体か角錐台(ピラミッドの上端を切り落としたような形)になります。原点は空間の中心です(通常は視点座標と一致します)。ビュー座標系からクリップ座標系への変換は「プロジェクション変換」と呼ばれます。

* **正規化デバイス座標系**<br>
クリップ座標系のX,Y,Z要素をW要素で除算した座標系です。この変換はクリッピングの直後に行われ、PAへの入力になります。英語の頭文字(Normalized Device Coordinates)から、NDCとも呼ばれます。<br>
ところで、この座標系とクリップ座標系はWで除算している以外に違いはありません。実際、グラフィックスハードウェアが必要とするのは正規化デバイス座標系のほうです。それならば、クリッピングも正規化デバイス座標系でやれば良さそうに思えますが(実際にそうなっているハードウェアもあります)、わざわざ分けているのは、コンピュータにとって除算が時間のかかる処理だからです。<br>
クリッピングによって表示されなくなる頂点に除算を実行するのは時間の無駄でしかありません。そこで、除算の前にクリッピングできるように定義されたのが、クリップ座標系というわけです。<br>
OpenGLにおいて、正規化デバイス座標系は±1の大きさを持つ空間です。この座標系の空間はXYZ各軸が±1の範囲を持つ立方体です。原点は空間の中心になります。<br>
クリップ座標系から正規化デバイス座標系への変換は、グラフィックスハードウェアが行います。そのため、この変換に特に名前はついていません。

* **スクリーン座標系**<br>
フレームバッファ上の座標系です。ウィンドウ座標系とも呼ばれます。OpenGLでは左下が原点です。正規化デバイス座標系からスクリーン座標系への変換は、グラフィックスハードウェアが行います。そのため、特に名前はありません。

さて、頂点データを定義している空間を表す座標系は「ワールド座標系」と説明しました。しかし、実際には「ローカル座標系であり、ワールド座標系であり、ビュー座標系であり、クリップ座標系でもあり、またNDC座標系でもある」というのが正しい説明になります。

こんな説明になる理由は、まだ座標変換のプログラムを書いていないので、頂点シェーダに入力する座標系は、出力される座標系と同じになっていなければ困るからです。ローカル座標系からクリップ座標系までが全て同じルールであるならば、座標変換の必要はありませんから。

そして、前回書いてもらった頂点シェーダーでは、w要素には常に1を設定しています。1で除算しても座標は変化しないので、クリップ座標系の座標と正規化デバイス座標系の座標は常に等しくなります。

### 2.2 右手座標系と左手座標系

ここまでは、目的に応じた座標系を説明してきました。それとは別に、各軸の向きに注目した座標系の分類があります。それが、「右手座標系」と「左手座標系」です。これは、親指から順にX,Y,Zの軸を割り当てていった時、ある座標系がどちらの手で表現できるかを示しています。

<div style="text-align: center;width: 100%;">
<img src="images/03_handed_coordinates.png" style="width:50%; margin-left:auto; margin-right:auto"/>
</div>

OpenGLでは伝統的に右手座標系が使われます。ところが、クリップ座標系から先は左手座標系が使われるんです。このため、シェーダでこの座標系の変換も行う必要があります。幸いなことに、右手座標系と左手座標系の変換はZ座標の符号を逆にするだけです。

>**【最初から左手座標系を使うわけにはいかないの？】**<br>基本的にはなんの問題もありません。実際、そのほうが座標変換は分かりやすくなるでしょう。現代のGPUは右手座標系を採用するDirectXとともに発展してきましたが、OpenGLはそれ以前から右手座標系を採用していました。<br>
そうした歴史的背景から、既存のOpenGL用プログラムやライブラリは、ほとんどが右手座標系を採用しています。そのため、素直に右手座標系を使うほうが手間がかかりません。もちろん、既存の資産を捨て去り、全てのプログラムを自分で作り上げるつもりなら、どちらでも好きな座標系を使うことができます。

<div style="page-break-after: always"></div>

## 3. 座標変換

### 3.1 <ruby>OpenGL Mathematics<rt>オープンジーエル・マスマティックス</rt></ruby>(GLM)の導入

これまではワールド座標系だけで暮らしてきましたが、いよいよ新たな座標系を導入していこうと思います。今回は「ローカル座標」、「ワールド座標系」、「ビュー座標系」、「クリップ座標系」を扱います。

複数の座標系を扱うとき、ある座標系で定義された座標が、別の座標系ではどのような座標として見えるかを計算する必要が生じます。この計算のことを「座標変換」といいます。

コンピューター・グラフィックスの世界では、座標変換は「4行4列の行列と座標の積」として表わされます。 行列と座標、あるいは行列と行列の演算はかなり面倒です。例えば4行4列の行列同士の積を計算するには、64回の乗算と48回の加算が必要です。こういった計算は、ライブラリに任せるのがいいでしょう。今回は`GLM`(ジーエル・エム)というライブラリを使うことにします。

メニューから「プロジェクト→NuGetパッケージの管理」を選択し、ソリューションのNuGetパッケージ管理ウィンドウが開いてください。ウィンドウが開いたら「参照」を選択して(①)、検索用テキストボックスに「glm」と入力します(②)。いくつか候補が表示されると思いますが、その中から「glm」というパッケージを選びます(③)。右側のインストールボタンをクリックするとインストールが開始されます(②)。インストールが完了したら、NuGetパッケージ管理ウィンドウを閉じてください。

<div style="text-align: center;width: 100%;">
<img src="images/03_install_glm_by_nuget.png" style="width:80%; margin-left:auto; margin-right:auto"/>
</div>

### 3.2 ヘッダファイルのインクルード

`GLM`ライブラリのインストールが終わったら、`Main.cpp`にヘッダファイルをインクルードしましょう。`Main.cpp`を開き、インクルード文を次のように変更してください。

```diff
 #include <glad/glad.h>
 #include "GLContext.h"
+#include <glm/gtc/matrix_transform.hpp>
 #include <GLFW/glfw3.h>
 #include <string>
 #include <iostream>
```

`GLM`ライブラリは用途別にヘッダファイルが分けられています。今回インクルードしている`matrix_transform.hpp`(マトリクス・トランスフォーム・エイチピーピー)には座標変換を行う関数が定義されています。

### 3.3 行列積の計算回数

ローカル座標からワールド座標への変換は「モデル変換」と呼ばれます。ワールド座標系からビュー座標系への変換は「ビュー変換」と呼ばれます。ビュー座標系からクリップ座標系への変換は「プロジェクション変換」と呼ばれます。

|名前|変換内容|
|:-:|:--|
|モデル変換|ローカル座標系の座標をワールド座標系の座標に変換|
|ビュー変換|ワールド座標系の座標をビュー座標系の座標に変換|
|プロジェクション変換|ビュー座標系の座標をクリップ座標系の座標に変換|

また、行列同士の積を座標に掛けた結果は、行列と座標の積を残りの行列に掛けた結果と等しくなります。

`行列・(行列・座標) = (行列・行列)・座標`

行列と行列の積には64回の乗算と48回の加算が必要なのでした。行列と座標の積の場合は、16回の乗算と12回の加算が必要です。また、行列同士の積の結果は行列になり、行列と座標の積の結果は座標になります。

このことから、左辺の計算回数は`(16+12)×2=56`回、右辺の計算回数は`64+48+16+12=140`回になります。同じ計算でも、左辺のほうがお得なんですね。

しかし、たくさんの座標に対して同じ計算をする場合はどうでしょうか。100個の座標があり、行列が変化しないとすると、左辺の場合は

`(16+12)×2×100 = 28×2×100 = 5600`

右辺の場合は

`64+48+(16+12)×100 = 112+28×100 = 2912`

となり、なんと右辺の計算式のほうが倍近くお得になります。 つまり、たくさんの頂点に対して座標変換を行うときは、先に行列の積を計算しておけば、大きく計算回数を減らすことができるわけです。

>**【等しいけれど等しくない？】**<br>
右辺と左辺は、理論上は全く同じ結果になるはずです。コンピューターによる浮動小数点数の計算では、順序が異なるとわずかに異なる結果になります。なぜなら、`float`型や`double`型は、少数点以下の値を正確に表現できるとは限らないからです。<br>
有名なところでは「`0.1`を10個足しても`1.0`にならない」という例があります。常に不正確なわけではなく、例えば`0.125`を8個足すと`1.0`になります。<br>
これは本当に小さな違いなので、3Dグラフィックスのように精度より速度が重要な用途では、大抵は目をつぶることになっています。また、本テキストで扱う座標変換ではどちらの式も同程度に不正確なので、気にしても仕方がありません。

<div style="border:solid 1px; background:#f0e4cd; margin: 1rem; padding: 1rem; border-radius: 10px">
<strong>【課題01】</strong><br>
右辺の計算式のほうがお得になるために必要な最小の頂点数<i>n</i>を計算しなさい。
</div>

### 3.4 シェーダーの変更

座標変換は頂点シェーダーで行います。`Main.cpp`を開き、頂点シェーダーを次のように書き換えてください。

```diff
   "out gl_PerVertex { \n"
   "  vec4 gl_Position; \n"
   "}; \n"
+  "layout(location=0) uniform mat4 matMVP; \n"
   "void main() { \n"
   "  outColor = vColor; \n"
-  "  gl_Position = vec4(vPosition, 1.0); \n"
+  "  gl_Position = matMVP * vec4(vPosition, 1.0); \n"
   "}";
```

ひとつめの変更は`matMVP`(マット・エムブイピー)というグローバル変数が追加されていることです。MVPという名前はMost Valuable Player(モスト・バリューアブル・プレイヤー)…ではなく、Model View Projection(モデル・ビュー・プロジェクション)の頭文字が由来です。なぜこの名前なのかというと、モデル変換、ビュー変換、プロジェクション変換という3つの行列の積を代入するつもりだからです。

`matMVP`変数の型は`uniform mat4`となっています。`uniform`(ユニフォーム)は、CPUからGPUへコピーされるパラメータであることを示します。`uniform`型の変数に書き込めるのはCPU側だけです。GPU(シェーダー)側では読み取り専用となり変更できません。プリミティブの描画中は変化しないことから「均一な、一様な」という意味の`uniform`という名前が付けられています。

`mat4`(マット・フォー)は4行4列の行列を表す型です。行列には他にも`mat3`(3行3列)や`mat2`(2行2列)といったものがあります。行と列を`x`(小文字のエックス)でつなぐ`mat4x4`(マット・フォー・バイ・フォー)という書き方もあります。なお、`mat`は`matrix`(マトリクス、行列)という単語を省略したものです。

`in`変数や`out`変数と同じく、`uniform`変数にもロケーションを指定できます。`uniform`変数の場合、この番号は「アプリケーションからデータを受け取るための位置情報」として使われます。用途が違うので`in`、`out`と同じロケーション番号を指定できます。

ふたつ目は、`gl_Position`の計算を変更したことです。といっても、頂点座標に`matMVP`を掛けただけです。

ところで、行列と座標の積を求めるには、28回の計算が必要なのでした。しかし、積を計算するたびにそんなに多くの計算を書くのは面倒すぎます。そのため、`GLSL`では、行列同士の積、行列と座標の積は、普通の掛け算と同じように`*`記号で表せるようになっています。

ただし、簡単に書けるだけで、内部的には28回の計算が行われることには変わりがありません。不必要な計算は避けるようにしましょう。

これでシェーダーの準備はできました。

### 3.5 座標変換行列を作成する

次は、CPUつまりアプリケーション側で座標変換行列を作成しましょう。ここからは、モデル変換を行う座標変換を「モデル行列」、ビュー変換を行う行列を「ビュー行列」、プロジェクション変換を行う行列を「プロジェクション行列」と呼ぶことにします。

各行列にはそれぞれ異なる役割があります。そのため、行列を作成する方法も異なっています。`GLM`ライブラリには、これらの行列を作成するための関数が用意されています。

|行列名|関数名|
|:--|:--|
|モデル行列|translate(トランスレート)<br>rotate(ローテート)<br>scale(スケール)|
|ビュー行列|lookAt(ルック・アット)|
|プロジェクション行列|perspective(パースペクティブ)<br>ortho(オーソ)|

これらの関数を使って変換行列を作っていきましょう。メインループ内の`glClear`関数呼び出しの下に、以下のプログラムを追加してください。

```diff
     glEnable(GL_DEPTH_TEST);
     glClearColor(0.1f, 0.3f, 0.5f, 1.0f);
     glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+
+    // 座標変換行列を作成してシェーダーに転送する.
+    int w, h;
+    glfwGetWindowSize(window, &w, &h);
+    const float aspectRatio = static_cast<float>(w) / static_cast<float>(h);
+    const glm::mat4 matProj =
+      glm::perspective(glm::radians(45.0f),  aspectRatio, 0.1f, 200.0f);
+    const glm::mat4 matView =
+      glm::lookAt(glm::vec3(2, 3, 3), glm::vec3(0, 0, 0), glm::vec3(0, 1, 0));
+    const glm::mat4 matModel = glm::mat4(1);
+    const glm::mat4 matMVP = matProj * matView * matModel;

     glBindVertexArray(vao);
     glBindProgramPipeline(pipeline);
```

`matModel`(マット・モデル)、`matView`(マット・ビュー)、`matProj`(マット・プロジェ)の３つがそれぞれモデル行列、ビュー行列、プロジェクション行列を表しています。これらの変数は`glm::mat4`型として定義しています。`GLM`ライブラリは`GLSL`とほぼ同じ書き方ができるように設計されているので、頭に`glm::`がつくことを除けば、`GLSL`と同じ型や関数が使えます。

`glm::perspective`(ジーエルエム・パースペクティブ)は、透視投影を行うプロジェクション行列を作成します。

<p><code class="tnmai_code"><strong>【書式】</strong><br>
glm::mat4 glm::perspective(視野角, アスペクト比, 描画範囲の手前側, 描画範囲の奥側);
</code></p>

「透視投影」は、近くにあるプリミティブほど大きく、遠くにあるプリミティブほど小さくなるような変換で、みなさんが現実の世界を見るのと同じように3D空間を見るための変換方法です。

最初の引数にはY軸(垂直)方向の視野角を弧度法で指定します。ただ、弧度法は直感的ではないので、`glm::radians`(ジーエルエム・ラジアンズ)関数を使って、度数法の値から弧度法に変換しています。角度を大きくすると広角レンズのように表示され、狭くすると望遠レンズのように表示されます。

2つめの引数は、Y軸に対するX軸の比率です(アスペクト比といいます)。通常は「描画範囲の幅÷描画範囲の高さ」を渡します。描画範囲は`glfwGetWindowSize`(ジーエルエフダブリュー・ゲット・ウィンドウ・サイズ)関数で取得できます。

3つめと4つめの引数は、奥行き方向の描画範囲を設定します。今回は、Z座標が0.1～200の範囲にあるプリミティブだけが描画されるようにしました。

`glm::lookAt`(ジーエルエム・ルック・アット)は、ワールド座標系からビュー座標系への変換を行うビュー行列を作成します。

<p><code class="tnmai_code"><strong>【書式】</strong><br>
glm::mat4 glm::lookAt(視点, 注視点, 視点の上方向ベクトル);
</code></p>

「視点」はみなさんの頭やカメラの位置のことです。「注視点」は注目している物や場所の位置です。そして「上方向ベクトル」は視点の傾きを表します。みなさんの頭を視点とすると、上方向ベクトルは頭のてっぺんからまっすぐ上にのびています。首を傾けると、上方向ベクトルも傾きます。視点と注視点の2つだけでは、この「傾ける」という動作を表現できませんよね。だから、上方向ベクトルが必要なのです。

そういうわけで、上記のプログラムは「ワールド座標系の(2, 3, 3)に視点があり、そこから(0, 0, 0)を注目していて、視点は傾いていないビュー座標系」への変換行列を作っていることになります。

モデル行列は、プリミティブをワールド座標の「どこへ」「どのような大きさで」「どんな角度で」表示するかを決める行列です。それぞれ`translate`、`scale`、`rotate`という関数で行列を作成し、それらの積をモデル行列とします。

ただし、今回はいずれの関数も使わず「単位行列」を設定しています。単位行列は`glm::mat4(1)`という式で作成できます。「単位行列」は次のような、左上から右下の斜めの部分だけ1で、他はすべて0になっている行列です。

```c++
　　　　   1 0 0 0
単位行列 = 0 1 0 0
　　　　   0 0 1 0
　　　　   0 0 0 1
```

単位行列は、他の行列や座標に掛けたとき何も変化させない(ルールを変えない)変換行列です(実数の`1.0`のようなものです)。

>**【補足】**<br>
インターネットにある`GLM`ライブラリを使ったサンプルのなかには、`glm::mat4()`のように引数無しで単位行列を作成しているものがあります。これは間違いではありません。古い(v0.9.9.0より前の)バージョンでは、引数を指定しなくても単位行列が作れたからです。<br>
しかし、`GLM`ライブラリが手本とする`GLSL`では最初から引数が必要でした。そのため、v0.9.9.0において、単位行列や単位ベクトルを作るときは引数を必要とするように修正されたのです。

3つの座標変換行列を手に入れたあとは、それをかけ合わせることで行列を合成しています。3.3節で説明したように、計算回数を減らすために行列同士の積を求めるわけです。また、シェーダーへ送る行列がひとつだけで済むというのも利点です。

>**【行列積は交換法則が成り立たない！？】**<br>
>行列を掛ける順番はとても重要です。なぜなら、行列の乗算では、みなさんが慣れ親しんでいる交換法則が成り立たないからです。実数または虚数の数値aとbがあるとき、<br>
>`a × b = b ×a`<br>
>が成り立ちますよね。だから、2×4でも4×2でも、答えは同じ8になるわけです。ですが、行列の場合は<br>
>`mA × mB ≠ mB × mA`<br>
>となります。2行2列で確認してみましょう。
>
>```c++
>|1 2| × |5 6| = |1×5+3×6 2×5+4×6| = |23 34|
>|3 4|   |7 8|   |1×7+3×8 2×7+4×8|   |31 46|
>
>|5 6| × |1 2| = |5×1+7×2 6×1+8×3| = |19 30|
>|7 8|   |3 4|   |5×3+7×4 6×2+8×4|   |43 44|
>```
>順番を変えると結果が全く違いますね。プリミティブが思ったように表示されないときは、行列を掛ける順番が正しいかどうかを確認してみるといいでしょう。

### 3.6 座標変換行列をシェーダに転送する

アプリケーションからシェーダーにデータを送るには、転送先となる`uniform`変数のロケーション番号が必要となります。これはシェーダを書くときに指定しましたね。

しかし、単に`0`と書いてもなんのことだか分かりづらいです。そこで、ロケーション番号を表す定数を定義しておきます。パイプライン・オブジェクトを作成するプログラムの下に、次のプログラムを追加してください。

```diff
   if (!pipeline) {
     return 1;
   }
+
+  // uniform変数の位置.
+  const GLint locMatMVP = 0;

   // メインループ.
   while (!glfwWindowShouldClose(window)) {
```

この値を`locMatMVP`(ロク・マット・エムブイピー)という変数に格納します。`loc`は`location`(ロケーション)の短縮形、`Mat`は`Matrix`(マトリクス)の短縮形です。

ロケーション番号には`GLuint`ではなく`GLint`を使います。`u`しか違いがなくて間違えやすいので注意してください。

それでは、ロケーション定数を使って行列を`uniform`変数に転送しましょう。行列の転送には`glProgramUniformMatrix4fv`(ジーエル・プログラム・ユニフォーム・マトリクス・フォー・エフ・ブイ)関数を使います。MVP行列を作成するプログラムの下に、次のプログラムを追加してください。

```diff
       glm::lookAt(viewPos, glm::vec3(0), glm::vec3(0, 1, 0));
     const glm::mat4 matModel = glm::mat4(1);
     const glm::mat4 matMVP = matProj * matView * matModel;
+    glProgramUniformMatrix4fv(vp, locMatMVP, 1, GL_FALSE, &matMVP[0][0]);

     glBindVertexArray(vao);
     glBindProgramPipeline(pipeline);
```

<p><code class="tnmai_code"><strong>【書式】</strong><br>
glProgramUniformMatrix4fv(プログラム・オブジェクトID, 転送位置,<br>
&emsp;転送する行列の数, 転置の有無, 転送する行列のアドレス);
</code></p>

この関数の最初の引数は、転送先となるプログラム・オブジェクトのIDです。2つ目は転送先のuniform変数の位置です。3つめの引数は、転送する行列の数です。4つめの引数は、行列を転置するかどうかを指定します(転置というのは行と列の内容を入れ替えることです)。

5つめの引数は、転送するデータへのポインタです。上記のプログラムでは`&matMVP[0][0]`とすることで、行列の最初の要素へのポインタを渡しています。

プログラムが書けたらビルドして実行してください。次のように斜め上から見たような画像が表示されたら成功です。

<div style="text-align: center;width: 100%;">
<img src="images/03_result_3.png" style="width:50%; margin-left:auto; margin-right:auto"/>
</div>

>**【短縮形と頭文字】**<br>
>単語をまったく短縮しないで`locationMatrixModelViewProjection`などと書くのは面倒なうえ、プログラムが読みづらくなりがちです。短縮形をうまく使うとプログラムが読みやすくなります。<br>
>ただし、なにもかも短縮するのはやりすぎです。基本的には、ローカル変数のように利用する範囲が狭いものや、メンバ変数のようにクラス名などで修飾されるものについて短縮形を使います。<br>
>短縮形を使うときはルールを決めておきましょう。同じ単語なのに書いた場所によって短縮形が違っていると、プログラムの意図を読み取るのに苦労します。また、いちいち短縮形を考える手間もなくなります。<br>
本テキストでは単語の先頭3文字が短縮形の基本です。また、行列における`MVP`などのように、元の単語が明らかな場合は頭文字を使うことがあります。

### 3.7 座標系の違い

さて、ここでふたつの重要なお知らせがあります。座標変換行列を導入した結果、<br>
**頂点データを定義しているワールド座標のルールと、それ以外の座標系のルールは違うものになりました。**<br>
これまではどちらも`左手座標系`ルールだったのですが、座標系を気にするようなプログラムを書いてはいなかったので、このことに気づかなかったと思います。

特に注意してもらいたいのは、一般的なOpenGLの世界において、`クリップ座標系は左手座標系`、`ワールド座標系は右手座標系`になっていることです。座標変換に使っている`GLM`ライブラリでは、OpenGLの一般的なワールド座標系を作り出します。ですから、作成しているプログラムも一般的なものに変わったわけです。これにより、Z軸の方向が逆になりました。

それと、以前は正方形として表示されていた四角形が、少し縦長に表示されていましたよね。実はこれが本当の形です。元々縦長の図形だったのが、画面サイズが`1280x720`と横長なために、`スクリーン座標系`への変換の過程で左右に引き伸ばされていたのです。

ただ、「画面サイズを変えると見た目も変わる」というのは、あまり見栄えがよくありません。そこで、一般的には透視投影変換のタイミングで縦横の比率(アスペクト比)を考慮した変換行列を作るようにします。`glm::perspective`関数でこの比率を考慮した行列を作るようにプログラムを変えましたから、今後は頂点データで定義したとおりの図形を表示できます。

もうひとつ、ワールド座標系の大きさの単位を`1メートル`に決めました。これからは、プログラムで距離を`1.0`と書いたとき、それは`1メートル`を意味することになります。

これまでは特に単位は決めておらず謎のままでした。単位を決めたことで、描画する四角形が`0.5x0.8m`の大きさであることや、視点がどのあたりの位置にあるのかが理解しやすくなると思います。

>**【ワールド座標系の単位はどうやって決める？】**<br>
ワールド座標系における`1.0`をどれくらいの大きさにするべきかは、表示したい内容によって異なります。人間やそれに近い大きさのものを表示するなら`1メートル`は分かりやすい単位でしょう。惑星規模の映像を表示したいなら`1キロメートル`にしてもいいでしょう。また、小さな動物が活躍するようなゲームなら、`1センチメートル`単位にすることも考えられます。ワールド座標の単位はプランナー、アーティスト、プログラマーが相談して決めます。

### 3.7 視点を動かす

四角形が斜めになったのは分かりますが、この状態では2つの図形の位置関係がさっぱり分かりません。そこで、視点を回転させてみましょう。

今回は`glm::rotate`関数を使い、視点を1秒間に10度の速度で回転させてみます。メインループの`glClear`関数呼び出しの下に、次のプログラムを追加してください。

```diff
   while (!glfwWindowShouldClose(window)) {
     glClearColor(0.1f, 0.3f, 0.5f, 1.0f);
     glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+
+    // 視点を回転させる.
+    const float degree = static_cast<float>(std::fmod(glfwGetTime() * 10.0, 360.0));
+    const glm::mat4 matViewR =
+      glm::rotate(glm::mat4(1), glm::radians(degree), glm::vec3(0, 1, 0));
+    const glm::vec3 viewPosition = matViewR * glm::vec4(2, 3, 3, 1);

     // 座標変換行列を作成してシェーダーに転送する.
     int w, h;
     glfwGetWindowSize(window, &w, &h);
```

変数`degree`(デグリー)は、度数による回転角度を表します。角度はプログラムが実行されてからの経過秒数から計算することにします(`degree`は「度」という意味で、度数法による角度を表します)。`GLFW`ライブラリには、経過秒数を取得する`glfwGetTime`(ジーエルエフダブリュー・ゲット・タイム)関数があるので、これを使うことにしました。

回転速度は秒間10度なので、経過秒数に10を掛けます。そして、1周分にあたる360で割った余りを計算します。浮動小数点数には`%`演算子が使えませんので、代わりに`std::fmod`(エスティーディー・エフ・モッド)という関数を使います。

また、`glfwGetTime`が返す経過秒数は`double`型ですが、`GLM`ライブラリの関数は主に`float`型を使います。そこで、`static_cast`で`float`型に変換しておきます。

角度を計算したら、それを元に「回転行列」を作ります。これには`glm::rotate`関数を使います。

<p><code class="tnmai_code"><strong>【書式】</strong><br>
glm::mat4 glm::rotate(元になる行列, 弧度法による回転角度, 回転軸ベクトル);
</code></p>

`glm::rotate`は「回転角度と回転軸ベクトルから回転行列を作り、元になる行列に右から掛けた結果を返す」関数です。計算結果は`matViewR`(マット・ビュー・アール)変数に格納します(末尾の`R`は`Rotate`の頭文字)。

回転行列ができたら、それをカメラの座標`(2, 3, 3)`に掛けます。なお、行列と座標を掛けるときは、座標の次数(数字の個数)を行列の列数(横方向の個数)に合わせなくてはならない、という決まりになっています。そこで、末尾に`1`を付け加えて次数を合わせます。

プログラムが書けたらビルドして実行してください。四角形がくるくると回り続けるようになると思います(実際には視点のほうが回転しているわけですが)。

### 3.8 深度バッファを使う

さて、視点を動かしてみると、2枚の四角形の前後関係がおかしいような気がします。目の錯覚…？　いいえ、錯覚ではありません。実際におかしくなっています。

OpenGLのプリミティブの描画順は、単純にインデックスデータで渡された順番になります。何もしなければピクセルはどんどん上書きされていきます。こういう仕組みなので、視点から見て奥にあるプリミティブがあとから描画されると、現実なら手前のプリミティブで隠れてしまう部分まで描画されてしまうのです。

これを防ぐには「深度バッファ」というものを使います。「深度バッファ」はピクセルごとの奥行き情報を格納しているメモリ領域です。ラスタライザ(RS)は、深度バッファに書かれた奥行きとフラグメントのZ値を比較し、深度バッファより手前にあると判断されたフラグメントだけを、フラグメントシェーダに送ります。

実は、深度バッファは`GLFW`が自動的に作成してくれています。わたしたちがしなければならないのは、深度バッファの利用を許可することだけです。`Main.cpp`に移動し、メインループの先頭に次のプログラムを追加してください。

```diff
   // メインループ.
   while (!glfwWindowShouldClose(window)) {
+    glEnable(GL_DEPTH_TEST);
     glClearColor(0.1f, 0.3f, 0.5f, 1.0f);
     glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
```

`glEnable`(ジーエル・イネーブル)関数は、OpenGLが持つさまざまな機能を有効にする関数です。

<p><code class="tnmai_code"><strong>【書式】</strong><br>
glEnable(有効にする機能のID);
</code></p>

深度バッファを有効にするには、引数に`GL_DEPTH_TEST`(ジーエル・デプス・テスト)を指定します。なお、機能を無効にするときは`glDisable`(ジーエル・ディセーブル)関数を使います。

`glEnable`関数にはさまざまな定数を指定することができますが、深度テスト以外で特に有用なのは、「裏面カリング(back-face culling)」という機能を示す`GL_CULL_FACE`(ジーエル・カル・フェイス)でしょう(cull(かる)は「集める、(集めて)取り除く」という意味の英単語です)。

ポリゴンで球や直方体を作った場合を考えてください。これらの形状が描画されるとき、裏を向いている面は表を向いている面によって隠されてしまうため、絶対に画面には映りません。表示されないのに描画するのは無駄ですよね。「裏面カリング」が有効になっていると、OpenGLは裏向きのポリゴンを描画しなくなります。

>**【表裏の決め方】**<br>
プリミティブの表裏を決めるのは頂点の位置関係です。例えば、三角形を構成するインデックスデータが0, 1, 2の順に定義されているとします。この3点が視点から見て反時計回りの順番で見えているとき、プリミティブは表向きになっています。時計回りの順番で見えているなら裏向きになっています。インデックスデータを作成するときは、このことに注意してください。

プログラムが書けたらビルドして実行してください。正しい前後関係で描画されるはずです。

<div style="border:solid 1px; background:#f0e4cd; margin: 1rem; padding: 1rem; border-radius: 10px">
<strong>【課題02】</strong><br>
頂点データのZ座標を変更して、2つの四角形が交差するようにしなさい。
</div>

<div style="border:solid 1px; background:#f0e4cd; margin: 1rem; padding: 1rem; border-radius: 10px">
<strong>【課題03】</strong><br>
裏面カリングを有効にしなさい。
</div>

<div style="page-break-after: always"></div>

## 4. VBO、IBOを部分的に描画する

### 4.1 データの追加

現在は、インデックスバッファに設定されているすべてのプリミティブを、一度の`glDrawElements`関数で描画しています。風景を表示するだけならこのままでも構わないのですが、ゲームのようなインタラクティブ性のあるアプリケーションを作る場合は、頂点やインデックスの一部分だけを表示したり、移動したりといったことが出来るべきでしょう。

`glDrawElements`関数は、描画に使うインデックスの範囲を指定できます。しかし今回は、さらに頂点データの位置もできる`glDrawElementsBaseVertex`(ジーエル・ドロー・エレメンツ・ベース・バーテックス)という関数を使うことにします。

<p><code class="tnmai_code"><strong>【書式】</strong><br>
glDrawElementsBaseVertex(プリミティブの種類, 描画するインデックスの数,<br>
&emsp;インデックスの型, インデックスデータの位置,<br>
&emsp;頂点データの位置);
</code></p>

引数は`glDrawElements`とほとんど同じですが、末尾に「頂点データの位置」が追加されています。あとで説明しますが、この引数があるとデータを作りやすくなるんです。

この関数を使う前に、今回の描画に使うデータを追加しましょう。緑の四角錐と茶色の三角錐を縦に重ねて「木」を表現してみることにします。`Main.cpp`を開き、`positions`配列と`colors`配列の先頭に、次のデータを追加してください。

```diff
 /// 座標データ.
 const Position positions[] = {
+  // 木
+  { 0.00f, 5.0f, 0.00f},
+  { 0.00f, 1.5f,-1.00f},
+  {-1.00f, 1.5f, 0.00f},
+  { 0.00f, 1.5f, 1.00f},
+  { 1.00f, 1.5f, 0.00f},
+  { 0.00f, 4.0f, 0.00f},
+  { 0.00f, 0.0f,-0.36f},
+  {-0.31f, 0.0f, 0.18f},
+  { 0.31f, 0.0f, 0.18f},
+
   {-0.3f, -0.3f, 0.5f},
   { 0.2f, -0.3f, 0.5f},
```

```diff
 /// 色データ.
 const Color colors[] = {
+  // 木
+  {0.5f, 0.8f, 0.3f, 1.0f},
+  {0.1f, 0.3f, 0.0f, 1.0f},
+  {0.1f, 0.3f, 0.0f, 1.0f},
+  {0.1f, 0.3f, 0.0f, 1.0f},
+  {0.1f, 0.3f, 0.0f, 1.0f},
+  {0.2f, 0.1f, 0.0f, 1.0f},
+  {0.5f, 0.3f, 0.2f, 1.0f},
+  {0.5f, 0.3f, 0.2f, 1.0f},
+  {0.5f, 0.3f, 0.2f, 1.0f},
+
   {0.0f, 1.0f, 0.0f, 1.0f},
   {0.0f, 0.0f, 1.0f, 1.0f},
```

四角錐には5つ、三角錐には4つの頂点が必要ですから、合計9個の頂点データを追加しています。追加した頂点データは「ローカル座標系」で定義されることに注意してください。今回作成する木のモデルでは、幹の中心が地面に接する点を原点としています。

頂点データの次はインデックスデータをついかしましょう。`indices`変数の先頭に、次のデータを追加してください。

```diff
 /// インデックスデータ.
 const GLushort indices[] = {
+  // 木
+  0, 1, 2, 0, 2, 3, 0, 3, 4, 0, 4, 1, 1, 4, 3, 3, 2, 1,
+  5, 6, 7, 5, 7, 8, 5, 8, 5,
+
   0, 1, 2, 2, 3, 0,
   4, 5, 6, 7, 8, 9,
 };
```

木を構成する三角形の数は、葉っぱにあたる緑の四角錐が6枚、幹にあたる茶色の三角錐は(地面当たる部分は見えないので)底面なしで3枚。合計9枚です。`GL_TRIANGLES`で描画する予定なので`3×9 = 27`個のインデックスを追加しています。

### 4.2 <ruby>Primitive<rt>プリミティブ</rt></ruby>クラスを作る

次に、描画するインデックスデータの範囲を表すクラスを作成します。このクラスはプリミティブ単位の描画データを表すつもりなので、名前はずばり`Primitive`(プリミティブ)とします。

ソリューションエクスプローラーの「ソースファイル」の上で右クリックメニューを開き、「追加→新しい項目」を選択して「新しい項目の追加」ウィンドウを開きます。そして、プロジェクトの`Src`フォルダに`Mesh.h`というヘッダファイルを追加してください。ファイルを追加したら、そのファイルに以下のプログラムを追加してください。

```diff
+/**
+* @file Mesh.h
+**/
+#ifndef MESH_H_INCLUDED
+#define MESH_H_INCLUDED
+#include <glad/glad.h>
+
+namespace Mesh {
+
+/**
+* プリミティブデータ.
+*/
+class Primitive
+{
+public:
+  Primitive() = default;
+  Primitive(GLenum m, GLsizei c, size_t o, GLint b) :
+    mode(m), count(c), indices(reinterpret_cast<GLvoid*>(o)), baseVertex(b)
+  {}
+  ~Primitive() = default;
+
+  void Draw() const;
+
+private:
+  GLenum mode = GL_TRIANGLES; ///< プリミティブの種類.
+  GLsizei count = 0; ///< 描画するインデックス数.
+  const GLvoid* indices = 0; ///< 描画開始インデックスのバイトオフセット.
+  GLint baseVertex = 0; ///< インデックス0番とみなされる頂点配列内の位置.
+};
+
+} // namespace Mesh
+
+#endif // MESH_H_INCLUDED
+
```

`Primitive`クラスには`glDrawElementsBaseVertex`関数の引数に対応するデータを格納します。`glDrawElementsBaseVertex`関数によって描画するためには、その引数に指定するデータが必要になるからです。

>**【なぜメッシュという名前を？】**<br>
`Mesh`(メッシュ)は「網、網目模様の織物」という意味の単語です。ポリゴンで作られたモデルの頂点をつなぐと網目模様に似ていることから、古くからモデルの形状データを指す単語として使われています。<br>
メッシュは複数のプリミティブをまとめた構造を取ることが多いです。

続いて、プロジェクトの`Src`フォルダに`Mesh.cpp`というcppファイルを追加してください。追加したファイルを開き、次のプログラムを追加してください。

```diff
+/**
+* @file Mesh.cpp
+*/
+#include "Mesh.h"
+
+/// 図形に関する機能を格納する名前空間.
+namespace Mesh {
+
+/**
+* プリミティブを描画する.
+*/
+void Primitive::Draw() const
+{
+  glDrawElementsBaseVertex(mode, count, GL_UNSIGNED_SHORT, indices, baseVertex);
+}
+
+} // namespace Mesh
+
```

`Draw`関数は、`Primitive`クラスのメンバ変数を`glDrawElementsBaseVertex`関数に渡してプリミティブを描画します。`glDrawElementsBaseVertex`関数は`glDrawElements`関数の兄弟で、追加の引数として「インデックスの0番とみなす頂点データの位置」を受け取ります。

インデックス型に`GLushort`を使う場合、頂点数は「全体で65536個まで」です。それ以上の頂点データがある場合は`GLuint`に切り替えなくてはなりません。しかし、ベースバーテックスを使う場合、この制限は「プリミティブごとに65536個まで」に変わります。

たとえ100万頂点のデータであっても、65536個以下のプリミティブに分割できれば`GLushort`で扱えるわけです。いくらインデックスデータが頂点データより小さいとはいえ、万単位ともなれば無視できない容量になります。サイズの小さな型で表せるなら、それに越したことはありません。

また、図形の見た目を調整するとき、頂点データを増やしたり減らしたりしたいことがあります。`glDrawElements`では、インデックスはすべての頂点データに対して一意でなければならないため、増減させた図形以降のインデックスもすべて変更する必要があります。

<div style="text-align: center;width: 100%;">
<img src="images/03_base_vertex_0.png" style="width:60%; margin-left:auto; margin-right:auto"/>
</div>

対して`glDrawElementsBaseVertex`ならば、インデックスのかわりにベース・バーテックスの番号を変更するだけで描画できます。

<div style="text-align: center;width: 100%;">
<img src="images/03_base_vertex_1.png" style="width:60%; margin-left:auto; margin-right:auto"/>
</div>

後半のインデックスが`0`から始まっていること、頂点データを増減させてもインデックスが変わらないことが分かるでしょうか。

>**【補足】**<br>
ベースバーテックスはプリミティブ単位で指定します。そのため、ひとつのプリミティブのなかで頂点データを増減させる場合、ベースバーテックスは無力です。しかし、変更の必要があるのはそのプリミティブのインデックスと、他のプリミティブのベースバーテックスだけです。すべてのインデックスを変えるよりはずっと簡単です。

### 4.3 Primitiveのリストを作る

`Primitive`クラスを使って、描画するインデックスの範囲を定義しましょう。まずは`Mesh.h`をインクルードします。`Main.cpp`を開き、`GLContext.h`のインクルード文の下に、次のプログラムを追加してください。

```diff
 #include <glad/glad.h>
 #include "GLContext.h"
+#include "Mesh.h"
 #include <glm/gtc/matrix_transform.hpp>
 #include <GLFW/glfw3.h>
 #include <string>
```

続いて、描画するインデックスの範囲を定義します。`indices`配列の下に、次のプログラムを追加してください。

```diff
   0, 1, 2, 2, 3, 0,
   4, 5, 6, 7, 8, 9,
 };
+
+// 描画データ.
+const Mesh::Primitive primTree(GL_TRIANGLES, 27, 0, 0);

 /// 頂点シェーダー.
 static const GLchar* const vsCode =
```

`primTree`(プリム・ツリー)変数は、さきほど追加した「木」のインデックスデータを表します。名前の`prim`は`primitive`を省略したもので、この変数がプリミティブデータだと分かるように付けています。

最初の引数はプリミティブの種類です。次の`27`という数字は、木が27個のインデックスでできていることを意味します。その次の`0`は木の描画に使う「最初のインデックスデータの位置」です。木のインデックスデータは`indices`配列の先頭、つまり0バイト目から始まっているので`0`を設定しています。先の`27`という数字と合わせると「インデックスデータの先頭から27個分」が木のデータの範囲ということです。

最後の`0`は、木の描画に使う「最初の頂点データの位置」です。木の頂点データは`positions`及び`colors`配列の先頭、つまり0番目にありますから、これも`0`を設定しています。

### 4.4 Primitiveクラスによる描画

それでは、`Primitive`クラスを使って描画してみましょう。メインループ内の`glDrawElements`関数呼び出しを次のように書き換えてください。

```diff
     glBindVertexArray(vao);
     glBindProgramPipeline(pipeline);

-    glDrawElements(
-      GL_TRIANGLES, sizeof(indices)/sizeof(indices[0]), GL_UNSIGNED_SHORT, 0);
+    primTree.Draw();

     glBindProgramPileline(0);
     glBindVertexArray(0);
```

ところで、現在の視点座標は`数十cm`の三角形や四角形がちょうど画面に収まる位置にしています。しかし、今回追加した木のモデルは高さが`5m`あるので、現在の視点からでは全体を映すことができません。そこで、視点の位置を変更しましょう。視点を回転させるプログラムを、次のように変更してください。

```diff
     const float degree = static_cast<float>(std::fmod(glfwGetTime() * 10.0, 360.0));
     const glm::mat4 matViewR =
       glm::rotate(glm::mat4(1), glm::radians(degree), glm::vec3(0, 1, 0));
-    const glm::vec3 viewPosition = matViewR * glm::vec4(2, 3, 3, 1);
+    const glm::vec3 viewPosition = matViewR * glm::vec4(20, 20, 30, 1);

     // 座標変換行列を作成してシェーダーに転送する.
     int w, h;
```

プログラムが書けたらビルドして実行してください。画面中央に、緑と茶色でできた細長い物体(木のつもり)が表示されていれば成功です。

### 4.5 木を動かす

現在、モデル行列には「単位行列」を設定しています。これが意味するところは「拡大縮小も回転もせずにワールド座標の原点に配置する」ということです。 好きな位置、好きな大きさ、好きな角度で表示できるようにするには、モデル行列を適切に設定しなければなりません。

モデル行列は以下の行列を組み合わせて作成します。

|名前|作成に使う関数|
|:--|:--|
|平行移動行列|<ruby>glm::translate<rt>ジーエルエム・トランスレート</rt></ruby>|
|回転行列|<ruby>glm::rotate<rt>ジーエルエム・ローテート</rt></rubh>|
|拡大縮小行列|<ruby>glm::scale<rt>ジーエルエム・スケール</rt></ruby>|

すでに説明したように、行列の乗算では交換法則が成り立ちません。そのため、上記の3つの行列を掛け合わせる順番が重要になってきます。この順序は3Dツールによってばらばらです。

しかし、ことゲームに関しては、多くの3Dゲームやエンジンで「拡大縮小→回転(X軸→Z軸→Y軸)→平行移動」の順が採用されています。ゲームキャラクターの姿勢を表すのには、この順番が最も都合がよいと考えられているからです。そういうことなので、本テキストでもこの順番でやっていきます。

とりあえずは平行移動、つまり位置を動かしてみましょう。右に10m、奥に1m動かすことにします。それでは、モデル行列を次のように書き換えてください。

```diff
     const glm::mat4 matView =
       glm::lookAt(viewPosition, glm::vec3(0), glm::vec3(0, 1, 0));
-    const glm::mat4 matModel = glm::mat4(1);
+    const glm::mat4 matModel = glm::translate(glm::mat4(1), glm::vec3(10, 0, -1));
     const glm::mat4 matMVP = matProj * matView * matModel;
     glProgramUniformMatrix4fv(vp, locMatMVP, 1, GL_FALSE, &matMVP[0][0]);
```

`glm::translate`は「平行移動ベクトルから平行移動行列を作り、元になる行列に右から掛けた結果を返す」関数です。

<p><code class="tnmai_code"><strong>【書式】</strong><br>
glm::mat4 glm::translate(元になる行列, 並行移動ベクトル);
</code></p>

プログラムが書けたらビルドして実行してください。木が先程と違う位置に立っていたら成功です。モデル行列を使うことで、頂点データは何も変えていないのに、表示する位置を変えることができました。

### 4.6 地面を作る

今の状態では本当に木の位置が変わったのか、視点の動きが変わっただけなのかが分かりにくいですね。そこで、基準となる地面を追加しましょう。大きさは原点を中心とする縦横40mの正方形で、明るい砂の地面とします。

まずは頂点データを追加します。`positions`と`colors`に次のプログラムを追加してください。

```diff
 /// 座標データ.
 const Position positions[] = {
+  // 地面
+  {-20, 0, 20},
+  { 20, 0, 20},
+  { 20, 0,-20},
+  {-20, 0,-20},
+
   // 木
   { 0.00f, 5.0f, 0.00f},
   { 0.00f, 1.5f,-1.00f},
```

<br>

```diff
 /// 色データ.
 const Color colors[] = {
+  // 地面
+  {0.8f, 0.7f, 0.5f, 1.0f},
+  {0.8f, 0.7f, 0.5f, 1.0f},
+  {0.8f, 0.7f, 0.5f, 1.0f},
+  {0.8f, 0.7f, 0.5f, 1.0f},
+
   // 木
   {0.5f, 0.8f, 0.3f, 1.0f},
   {0.1f, 0.3f, 0.0f, 1.0f},
```

ご覧の通り、地面の頂点データは4つ、つまり単純な四角形として作りました。

続いて、インデックスデータを追加しましょう。`indices`配列に次のプログラムを追加してください。

```diff
 /// インデックスデータ.
 const GLushort indices[] = {
+  // 地面
+  0, 1, 2, 2, 3, 0,
+
   // 木
   0, 1, 2, 0, 2, 3, 0, 3, 1, 1, 2, 3,
```

地面は一個の四角形としたので、三角形ふたつに相当する6個のインデックスデータを用意しています。

最後に、`Primitive`を追加します。描画データリストを次用に書き換えてください。

```diff
   4, 5, 6, 7, 8, 9,
 };

 /// 描画データリスト.
+const Mesh::Primitive primGround(GL_TRIANGLES, 6, 0, 0); // 地面
-const Mesh::Primitive primTree(GL_TRIANGLES, 27, 0, 4); // 木
+const Mesh::Primitive primTree(GL_TRIANGLES, 27, 6 * sizeof(GLushort), 4); // 木

 /// 頂点シェーダー.
 static const GLchar* const vsCode =
```

`primTree`の引数を変更していることに注意してください。`6 * sizeof(GLushort)`の部分は木のインデックスデータの最初のバイト位置を表しています。

インデックスデータは「地面→木」の順です。地面のインデックスデータは`6`個なので、それにインデックス1個分のバイト数を掛けると、木のデータの開始位置が計算できます。もし木の次にデータを追加するなら、その開始位置は地面と木のデータ数を足して`33 * sizeof(GLushort)`になるでしょう。

最後の引数`4`はベースバーテックスです。インデックスデータと同じく、木の頂点データも地面の直後にあります。地面の頂点データは4個なので、木のベースNoは`4`になります。これで地面は完成です。

### 4.7 地面を描画する

作成した地面を表示しましょう。3Dグラフィックスでは画面に表示されるキャラクターは、それぞれ固有のローカル座標系を持ちます。言い換えると、木と地面は別々のモデル行列を使うということです。

木を描画するプログラムの下に、次のプログラムを追加してください。

```diff
     glBindProgramPipeline(pipeline);

     primTree.Draw();
+
+    // 地面を描画.
+    {
+      const glm::mat4 matModel = glm::mat4(1);
+      const glm::mat4 matMVP = matProj * matView * matModel;
+      glProgramUniformMatrix4fv(vp, locMatMVP, 1, GL_FALSE, &matMVP[0][0]);
+      primGround.Draw();
+    }

     glBindProgramPileline(0);
     glBindVertexArray(0);
```

このプログラムは、地面用のモデル行列を作成し、さらにそのモデル行列を掛けたMVP行列を作成してシェーダーに転送します。そのあとで地面を描画しています。プログラムが書けたらビルドして実行してください。茶色の地面が表示されたら成功です。

<div style="text-align: center;width: 100%;">
<img src="images/03_result_4.png" style="width:50%; margin-left:auto; margin-right:auto"/>
</div>

### 4.8 複数の木を植える

木が1本だけではさびしいので、もっとたくさん植えたいですね。好きな場所に好きな数だけ木を植えるには、木を植えるたびにモデル換行列を書き換えます。`for`を使って地面の端に19本の木を並べて植えてみましょう。木を表示するプログラムを、次のように変更してください。

```diff
   const glm::mat4 matView =
     glm::lookAt(viewPosition, glm::vec3(0), glm::vec3(0, 1, 0));
-  const glm::mat4 matModel = glm::translate(glm::mat4(1), glm::vec3(5, 0, 1));
-  const glm::mat4 matMVP = matProj * matView * matModel;
-  glProgramUniformMatrix4fv(vp, locMatMVP, 1, GL_FALSE, &matMVP[0][0]);

   glBindVertexArray(vao);
   glBindProgramPipeline(pipeline);

-  primTree.Draw();
+
+   // 木を描画.
+   for (float i = 0; i < 19; ++i) {
+     const glm::mat4 matModelT =
+       glm::translate(glm::mat4(1), glm::vec3(-19 + i * 2, 0, 19));
+     const glm::mat4 matModelR =
+       glm::rotate(glm::mat4(1), glm::radians(i * 90), glm::vec3(0, 1, 0));
+     const glm::mat4 matModel = matModelT * matModelR;
+     const glm::mat4 matMVP = matProj * matView * matModel;
+     glProgramUniformMatrix4fv(vp, locMatMVP, 1, GL_FALSE, &matMVP[0][0]);
+     primTree.Draw();
+   }

    // 地面を描画.
    {
```

プログラムが書けたらビルドして実行してください。地面の端に19本の木が植えられていたら成功です。

<div style="text-align: center;width: 100%;">
<img src="images/03_result_5.png" style="width:50%; margin-left:auto; margin-right:auto"/>
</div>

<div style="border:solid 1px; background:#f0e4cd; margin: 1rem; padding: 1rem; border-radius: 10px">
<strong>【課題04】</strong><br>
地面の残り3辺に木を並べて表示しなさい。<br>
簡単な方法: 木を植えるforループを3回コピペして、それぞれ植え始めの位置と植える方向を変える。<br>
少し難しい方法: 木を植えるforループを関数にして4個書く。植え始めの位置と植える方向、その他必要な変数は引数で指定する。<br>
難しい方法: 普通の方法と同様に関数にするが、関数を4個書くかわりにforループを使う。
</div>
