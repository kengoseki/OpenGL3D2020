[OpenGL 3D 2020 第06回]

# 面倒なのは嫌なのでクラスに極振りしたいと思います

## 習得目標

* 変数と関数をクラスで置き換える方法

## 1. プリミティブを作りやすくする

### 1.1 <ruby>PrimitveBuffer<rt>プリミティブ・バッファ</rt></ruby>クラスを定義する

`Primitive`クラスの変数を定義するには、頂点データとインデックスデータの位置を正確に指定しなければなりません。どこかの頂点データやインデックスデータの数を変更すると、その頂点データを使っている`Primitive`だけでなく、それより後の頂点データを使っている全ての構造体も修正しなければなりません。

そのため、頂点データの変更や修正を手作業で行うのは面倒ですし、間違いを起こしやすいです。そこで、もっと手軽にデータの変更や追加をできるようにしていきましょう。

まず「`Primitive`を管理するクラス」を作ります。このクラスの名前を`PrimitiveBuffer`(プリミティブ・バッファ)としましょう。`PrimitiveBuffer`には「`Primitive`の配列」と、`VBO`、`IBO`、`VAO`といった「頂点データの管理に使うバッファオブジェクト」を持たせます。

次に、現在はひとかたまりになっている頂点データを、物体ごとに分離します。そして`PrimitiveBuffer`に対して、物体ごとに`Primitive`の追加を行います。`PrimitiveBuffer`は、その物体のデータをバッファオブジェクトに転送し、`Primitive`のパラメータを自動的に計算して配列に追加します。

最初に管理クラスを作りましょう。まずは配列用に`vector`クラスを使えるようにします。`Mesh.h`を開き、次のプログラムを追加してください。

```diff
 #ifndef MESH_H_INCLUDED
 #define MESH_H_INCLUDED
 #include <glad/glad.h>
+#include <glm/glm.hpp>
+#include <vector>

 /**
 * プリミティブデータ.
```

それでは`PrimitiveBuffer`クラスを定義しましょう。`Primitive`クラスの定義の下に、次のプログラムを追加してください。

```diff
   const GLvoid* indices = 0; ///< 描画開始インデックスのバイトオフセット.
   GLint baseVertex = 0; ///< インデックス0番とみなされる頂点配列内の位置.
 };
+
+/**
+* プリミティブバッファ.
+*/
+class PrimitiveBuffer
+{
+public:
+  PrimitiveBuffer() = default;
+  ~PrimitiveBuffer();
+
+  // コピーを禁止する.
+  PrimitiveBuffer(const PrimitiveBuffer&) = delete;
+  PrimitiveBuffer& operator=(const PrimitiveBuffer&) = delete;
+
+  // メモリ管理.
+  bool Allocate(GLsizei maxVertexCount, GLsizei maxIndexCount);
+  void Free();
+
+  // プリミティブの追加と参照.
+  bool Add(size_t vertexCount, const glm::vec3* pPosition, const glm::vec4* pColor,
+    const glm::vec2* pTexcoord, size_t indexCount, const GLushort* pIndex);
+  const Primitive& Get(size_t n) const;
+
+  // VAOバインド管理.
+  void BindVertexArray() const;
+  void UnbindVertexArray() const;
+
+private:
+  std::vector<Primitive> primitives;
+
+  GLuint vboPosition = 0;
+  GLuint vboColor = 0;
+  GLuint vboTexcoord = 0;
+  GLuint ibo = 0;
+  GLuint vao = 0;
+
+  GLsizei maxVertexCount = 0; // 格納できる最大頂点数.
+  GLsizei curVertexCount = 0; // 格納済み頂点数.
+  GLsizei maxIndexCount = 0; // 格納できる最大インデックス数.
+  GLsizei curIndexCount = 0; // 格納済みインデックス数.
+};

 #endif // MESH_H_INCLUDED
```

このクラスでは、まず`Allocate`(アロケート)メンバ関数によって`VAO`を作成し、GPUメモリを確保します。その後、`Add`(アド)メンバ関数によって`Primitive`を追加します。追加した`Primitive`は、`Get`メンバ関数で参照します。

また、`PrimitiveBuffer`クラスは`VAO`の管理も行います。クラス外からはその`VAO`にアクセスできないため、`BindVertexArray`(バインド・バーテックス・アレイ)メンバ関数で割り当てられるようにしています。`UnbindVertexArray`(アンバインド・バーテックス・アレイ)メンバ関数は割り当て解除用の関数です。

メンバ変数には全て初期値を指定しているので、コンストラクタは`default`指定をしてコンパイラに作成を任せています。しかし、デストラクタのほうは我々自身で定義しなければなりません。なぜなら、バッファオブジェクトの後始末をしなければならないからです。

メンバ変数で注目してほしいのは、`maxVertexCount`(マックス・バーテックス・カウント)から下の4つです。`maxVertexCount`と`maxIndexCount`(マックス・インデックス・カウント)は、バッファオブジェクトに格納できる頂点、インデックスの最大数を表します。この数まではデータを追加できるということです。`Allocate`の引数がそのまま設定され、`Free`が実行されるまで変化しません。

`curVertexCount`(カー・バーテックス・カウント)と`curIndexCount`(カー・インデックス・カウント)は、`Add`によって追加されたデータの合計を表します。`Add`によってデータを追加するたびに増加します。先頭にある`cur`(カー)は、`current`(カレント)の短縮形です。`current`は「今の」「現在の」という意味です。

## 1.2 デストラクタを定義する

それでは、メンバ関数を定義していきましょう。しかしその前に、いくつかのヘッダファイルをインクルードします。`Mesh.cpp`を開き、次のプログラムを追加してください。

```diff
 * @file Mesh.cpp
 */
 #include "Mesh.h"
+#include "GLContext.h"
+#include <iostream>

 /**
 * プリミティブを描画する.
```

続いてデストラクタを定義します。`Primitive::Draw`関数の定義の下に、次のプログラムを追加してください。

```diff
   glDrawElementsBaseVertex(mode, count, GL_UNSIGNED_SHORT, indices, baseVertex);
 }
+
+/**
+* デストラクタ.
+*/
+PrimitiveBuffer::~PrimitiveBuffer()
+{
+  Free();
+}
```

実際のバッファオブジェクトの後始末は`Free`メンバ関数で行います。デストラクタではその`Free`メンバ関数を呼び出すだけです。

### 1.3 <ruby>Allocate<rt>アロケート</rt></ruby>メンバ関数を定義する

次は`Allocate`メンバ関数を定義します。`Allocate`は「配分する、割り当てる」という意味で、この関数が、バッファオブジェクトの使うGPUメモリを割り当てる作業をすることから命名しています。それでは、デストラクタの定義の下に、次のプログラムを追加してください。

```diff
   Free();
 }
+
+/**
+* プリミティブ用のメモリを確保する.
+*
+* @param maxVertexCount  格納可能な最大頂点数.
+* @param maxIndexCount   格納可能な最大インデックス数.
+*
+* @retval true  確保成功.
+* @retval false 確保失敗、または既に確保済み.
+*/
+bool PrimitiveBuffer::Allocate(GLsizei maxVertexCount, GLsizei maxIndexCount)
+{
+  if (vao) {
+    std::cerr << "[警告]" << __func__ << ": VAOは作成済みです.\n";
+    return false;
+  }
+  vboPosition = GLContext::CreateBuffer(sizeof(glm::vec3) * maxVertexCount, nullptr);
+  vboColor = GLContext::CreateBuffer(sizeof(glm::vec4) * maxVertexCount, nullptr);
+  vboTexcoord = GLContext::CreateBuffer(sizeof(glm::vec2) * maxVertexCount, nullptr);
+  ibo = GLContext::CreateBuffer(sizeof(GLushort) * maxIndexCount, nullptr);
+  vao = GLContext::CreateVertexArray(vboPosition, vboColor, vboTexcoord, ibo);
+  if (!vboPosition || !vboColor || !vboTexcoord || !ibo || !vao) {
+    std::cerr << "[エラー]" << __func__ << ": VAOの作成に失敗.\n";
+    Free();
+    return false;
+  }
+  primitives.reserve(100);
+  this->maxVertexCount = maxVertexCount;
+  this->maxIndexCount = maxIndexCount;
+  return true;
+}
```

最初に`vao`メンバ変数をチェックします。`vao`変数が`0`以外なら既に確保済みなので`false`を返して終了します。既に確保済みなのにまた確保しようとするのはバグの可能性が高いからです。

`vao`変数が`0`だったら、`VBO`、`IBO`、`VAO`を作成します。いずれかの作成に失敗した場合は`Free`で後始末をして`false`を返します。

`VAO`の作成に成功したら、メモリの再確保を防ぐためにプリミティブ配列のサイズを予約し、頂点とインデックスの最大数を設定します。引数とメンバ変数の名前が同じときは、引数が優先して使われます。メンバ変数を操作したいときは、変数名の前に`this->`を付けます。

<p><code class="tnmai_code"><strong>【書式】</strong><br>
std::vector::reserve(予約する要素数);
</code></p>

`reserve`(リサーブ)関数は、`vector`型の変数がすぐに確保できる容量を予約します(`reserve`は「予約する」という意味です)。`vector`型は、最初に適当な大きさのメモリを確保して、そこにデータを詰め込んでいきます。データが確保したメモリに入り切らなくなったとき、より大きい別のメモリを確保しなおして、そちらにデータをコピーし、古いメモリを解放します。`vector`型がいくらでも大きな配列を作れるのは、このような仕組みになっているからです。

ただし、この方法にはひとつ問題があります。メモリの確保やデータのコピーにはそれなりの時間がかかるので、プログラムの動作が遅くなってしまうことがあるのです。

そこで`reserve`関数の出番です。`reserve`関数は指定された大きさのメモリを確保します(このとき配列の長さは変化しません)。`vector`型にデータを入れるより前に十分な大きさのメモリを確保しておけば、メモリの再確保やデータのコピーは起こりません。なお、もし`reserve`で予約したサイズで足りなくなったら、通常どおりメモリが再確保されてデータがコピーされます。

今回は100個のプリミティブまではデータのコピーが起こらないようにしてみました。いきなり100個も追加することはないでしょうが、これだけあれば、あとからみなさんがいろいろなデータを追加しても、すぐに足りなくなることはないでしょう。

### 1.4 <ruby>Free<rt>フリー</rt></ruby>メンバ関数を定義する

続いてバッファオブジェクトを削除する`Free`メンバ関数を定義しましょう。`Allocate`メンバ関数の定義の下に、次のプログラムを追加してください。

```diff
   this->maxVertexCount = maxVertexCount;
   return true;
 }
+
+/**
+* プリミティブ用のメモリを開放する.
+*/
+void PrimitiveBuffer::Free()
+{
+  primitives.clear();
+
+  glDeleteVertexArrays(1, &vao);
+  vao = 0;
+  glDeleteBuffers(1, &ibo);
+  ibo = 0;
+  glDeleteBuffers(1, &vboTexcoord);
+  vboTexcoord = 0;
+  glDeleteBuffers(1, &vboColor);
+  vboColor = 0;
+  glDeleteBuffers(1, &vboPosition);
+  vboPosition = 0;
+
+  maxVertexCount = 0;
+  curVertexCount = 0;
+  maxIndexCount = 0;
+  curIndexCount = 0;
+}
```

この関数は`glDeleteBuffers`と`glDeleteVertexArrays`を使って全てのオブジェクトを削除し、全てのメンバ変数に初期値を設定します。なお、`glDeleteBuffers`、`glDeleteVertexArrays`にゼロまたは未使用のIDを指定した場合、これらの関数は何もしません。ですから、IDが`0`かどうかのチェックは不要です。

メンバ変数の設定漏れがないように注意してください。

また、`primitives`については`clear`(クリア)メンバ関数を使っています。

<p><code class="tnmai_code"><strong>【書式】</strong><br>
std::vector::clear();
</code></p>

このメンバ関数は、配列の内容を消去して長さを`0`にします。保存しているデータが無くなるだけで、それを入れるためのメモリの大きさは変化しないことに注意してください。

### 1.5 <ruby>Add<rt>アド</rt></ruby>メンバ関数を定義する

次は`Add`メンバ関数を定義します。少し長い関数なので、雛形から作っていくことにしましょう。`Free`メンバ関数の定義の下に、次のプログラムを追加してください。

```diff
   storedVertexCount = 0;
 }
+
+/**
+* プリミティブを追加する.
+*
+* @param vertexCount 追加する頂点データの数.
+* @param pPosition   座標データへのポインタ.
+* @param pColor      色データへのポインタ.
+* @param pTexcoord   テクスチャ座標データへのポインタ.
+* @param indexCount  追加するインデックスデータの数.
+* @param pIndex      インデックスデータへのポインタ.
+*
+* @retval true  追加に成功.
+* @retval false 追加に失敗.
+*/
+bool PrimitiveBuffer::Add(size_t vertexCount, const glm::vec3* pPosition,
+  const glm::vec4* pColor, const glm::vec2* pTexcoord, size_t indexCount, const GLushort* pIndex)
+{
+
+  return true;
+}
```

まずはエラーチェックを加えましょう。考えられるのは、`Allocate`を実行していない、または実行に失敗した、あるいは確保したGPUメモリが残り少なくてデータをコピーできない、というものです。これらについてプログラムを書いていきます。`Add`メンバ関数に次のプログラムを追加してください。

```diff
 bool PrimitiveBuffer::Add(size_t vertexCount, const glm::vec3* pPosition,
   const glm::vec4* pColor, const glm::vec2* pTexcoord, size_t indexCount, const GLushort* pIndex)
 {
+  if (!vao) {
+    std::cerr << "[エラー]" << __func__ << ": Allocateが実行されていない、または失敗しています.\n";
+    return false;
+  } else if (maxVertexCount < curVertexCount) {
+    std::cerr << "[エラー]" << __func__ << ": 頂点カウントに異常があります(max=" <<
+      maxVertexCount << ", cur=" << curVertexCount << ")\n";
+    return false;
+  } else if (maxIndexCount < curIndexCount) {
+    std::cerr << "[エラー]" << __func__ << ": インデックスカウントに異常があります(max=" <<
+      maxIndexCount << ", cur=" << curIndexCount << ")\n";
+    return false;
+  } else if (vertexCount > static_cast<size_t>(maxVertexCount) - curVertexCount) {
+    std::cerr << "[警告]" << __func__ << ": VBOが満杯です(max=" << maxVertexCount <<
+      ", cur=" << curVertexCount << ", add=" << vertexCount << ")\n";
+    return false;
+  } else if (indexCount > static_cast<size_t>(maxIndexCount) - curIndexCount) {
+    std::cerr << "[警告]" << __func__ << ": IBOが満杯です(max=" << maxIndexCount <<
+      ", cur=" << curIndexCount << ", add=" << indexCount << ")\n";
+    return false;
+  }

   return true;
 }
```

`Allocate`が成功していることを調べるには、メンバ変数が初期値と違うことを確認します。成功していればバッファオブジェクトなどには`0`以外の値が入っているはずだからです。今回は`vao`をチェックに使うことにしました。

次に頂点とインデックスの最大値と現在の値を変数をチェックします。`cur`が`max`を超えることはありえないはずですが、プログラムのバグなどで発生しないとは言い切れません。もし超えていると、このあとのキャストが正常に行われない可能性があります。キャストが正常に行われることを保証するためにも、このエラーチェックは重要です。

カウント変数をチェックしたら、GPUメモリに十分な空きがあることを確認します。GPUメモリの残量は「最大数 - 現在の数」で計算できます。残量がコピーしたいデータ数より少ない場合は`false`を返して終了します。このとき`maxVertexCount`や`maxIndexCount`をキャストしているのは、引き算の結果が`GLsizei`で表しきれない可能性があるからです。

もちろん、そんなことはまずありえませんが、しかし、バグというのは本来ありえない状況でこそ起きるものです。だから、十分に備えておくことが重要なのです。

>**【エラーチェックの意義】**<br>
>プログラムが常に正しく書かれ、そのとおりに実行されるならエラーチェックなど書かなくてもよいはずです。しかし現実はそうではありませんから、できるだけ早い段階でエラーを見つけて対処しなくてはなりません。だから、エラーチェックが重要なのです。

エラーチェックの次は、データのコピーをしていきます。データのコピーには`glCopyNamedBufferSubData`(ジーエル・コピー・ネームド・バッファ・サブ・データ)関数を使います。エラーチェックプログラムの下に、次のプログラムを追加してください。

```diff
       ", cur=" << curIndexCount << ", add=" << indexCount << ")\n";
     return false;
   }
+
+  const GLsizei size = static_cast<GLsizei>(sizeof(glm::vec3) * vertexCount);
+  const GLuint tmp = GLContext::CreateBuffer(size, pPosition);
+  if (!tmp) {
+    std::cerr << "[エラー]" << __func__ << ": コピー元バッファの作成に失敗(size=" << size << ").\n";
+  }
+  const GLsizei offset = static_cast<GLsizei>(sizeof(glm::vec3) * curVertexCount);
+  glCopyNamedBufferSubData(tmp, vboPosition, 0, offset, size);
+  glDeleteBuffers(1, &tmp);
+  if (glGetError() != GL_NO_ERROR) {
+    std::cerr << "[エラー]" << __func__ << ": データのコピーに失敗(size=" << size <<
+      ", offset=" << offset << ").\n";
+    return false;
+  }

   return true;
 }
```

<p><code class="tnmai_code"><strong>【書式】</strong><br>
glCopyNamedBufferSubData(コピー元のバッファオブジェクトID, コピー先のバッファオブジェクトID,
&emsp;コピー元のオフセット, コピー先のオフセット, コピーするバイト数);
</code></p>

この関数は、あるバッファオブジェクトから別のバッファオブジェクトにデータをコピーします。`glNamedBufferStorage`関数の「利用方法」に`0`を指定した場合、既存のバッファオブジェクトに直接データをコピーすることはできません。そこで、まず`GLContext::CreateBuffer`関数で新しいバッファオブジェクトを作成し、`glCopyNamedBufferSubData`を使って既存のバッファオブジェクトにコピーする、という方法をとる必要があります。

データのサイズやコピー先の位置はバイト単位で指定するので、`sizeof(glm::vec3)`を掛けてバイト数を計算しています。

### 1.6 データのコピーを関数化する

さて、上記のプログラムでコピーしたのは座標データだけなので、残りの色データ、テクスチャ座標データ、インデックスデータも同じ方法でコピーしましょう。…と、言いたいところですが、いくらなんでも、こんなプログラムを4回も書くのは面倒すぎます。そこで、上記のプログラムを元にして、他のデータでも使えるような関数を作りましょう。`Mesh.cpp`の先頭に移動し、インクルード文の下に次のプログラムを追加してください。

```diff
 #include <glm/glm.hpp>
 #include <iostream>
+
+/**
+* データをバッファオブジェクトにコピーする.
+*
+* @param id          コピー先となるバッファオブジェクトID.
+* @param unitSize    要素のバイト数.
+* @param offsetCount コピー先オフセット(要素単位).
+* @param count       コピーする要素数.
+* @param data        コピーするデータのアドレス.
+*
+* @retval true  コピー成功.
+* @retval false コピー失敗.
+*/
+bool CopyData(GLuint id, GLsizei unitSize, GLsizei offsetCount, size_t count, const void* data)
+{
+  return true;
+}
```

次に、`Add`関数から以下の部分を切り取り（範囲選択して`Ctrl+X`)、

```diff
       ", cur=" << curIndexCount << ", add=" << indexCount << ")\n";
     return false;
   }

-  const GLsizei size = static_cast<GLsizei>(sizeof(glm::vec3) * vertexCount);
-  const GLuint tmp = GLContext::CreateBuffer(size, pPosition);
-  if (!tmp) {
-    std::cerr << "[エラー]" << __func__ << ": コピー元バッファの作成に失敗(size=" << size << ").\n";
-  }
-  const GLsizei offset = static_cast<GLsizei>(sizeof(glm::vec3) * curVertexCount);
-  glCopyNamedBufferSubData(tmp, vboPosition, 0, offset, size);
-  glDeleteBuffers(1, &tmp);
-  if (glGetError() != GL_NO_ERROR) {
-    std::cerr << "[エラー]" << __func__ << ": データのコピーに失敗(size=" << size <<
-      ", offset=" << offset << ").\n";
-    return false;
-  }

   return true;
 }
```

`CopyData`(コピー・データ)関数の中に貼り付けてください(`Ctrl+V`)。

```diff
 bool CopyData(GLuint id, GLsizei unitSize, GLsizei offsetCount, GLsizei count, const void* data)
 {
+  const GLsizei size = static_cast<GLsizei>(sizeof(glm::vec3) * vertexCount);
+  const GLuint tmp = GLContext::CreateBuffer(size, pPosition);
+  if (!tmp) {
+    std::cerr << "[エラー]" << __func__ << ": コピー元バッファの作成に失敗(size=" << size << ").\n";
+  }
+  const GLsizei offset = static_cast<GLsizei>(sizeof(glm::vec3) * curVertexCount);
+  glCopyNamedBufferSubData(tmp, vboPosition, 0, offset, size);
+  glDeleteBuffers(1, &tmp);
+  if (glGetError() != GL_NO_ERROR) {
+    std::cerr << "[エラー]" << __func__ << ": データのコピーに失敗(size=" << size <<
+      ", offset=" << offset << ").\n";
+    return false;
+  }
   return true;
 }
```

貼り付けたプログラムは`sizeof(glm::vec3)`や`pPosition`といった、座標データ専用の書き方のままです。それらを`CopyData`の引数に置き換えるすることで、他のデータにも使える関数にしましょう。座標データ専用のプログラムを、次のように書き換えてください。

```diff
 bool CopyData(GLuint id, GLsizei unitSize, GLsizei offsetCount, GLsizei count, const void* data)
 {
-  const GLsizei size = static_cast<GLsizei>(sizeof(glm::vec3) * vertexCount);
-  const GLuint tmp = GLContext::CreateBuffer(size, pPosition);
+  const GLsizei size = static_cast<GLsizei>(unitSize * count);
+  const GLuint tmp = GLContext::CreateBuffer(size, data);
   if (!tmp) {
     std::cerr << "[エラー]" << __func__ << ": コピー元バッファの作成に失敗(size=" << size << ").\n";
   }
-  const GLsizei offset = static_cast<GLsizei>(sizeof(glm::vec3) * curVertexCount);
-  glCopyNamedBufferSubData(tmp, vboPosition, 0, offset, size);
+  const GLsizei offset = static_cast<GLsizei>(unitSize * offsetCount);
+  glCopyNamedBufferSubData(tmp, id, 0, offset, size);
   glDeleteBuffers(1, &tmp);
   if (glGetError() != GL_NO_ERROR) {
     std::cerr << "[エラー]" << __func__ << ": データのコピーに失敗(size=" << size <<
       ", offset=" << offset << ").\n";
```

これで`CopyData`関数は完成です。

### 1.7 Addメンバ関数を完成させる

それでは、`Add`メンバ関数に戻りましょう。エラーチェックプログラムの下に、次のプログラムを追加してください。

```diff
       ", cur=" << curIndexCount << ", add=" << indexCount << ")\n";
     return false;
   }

+  if (!CopyData(vboPosition, sizeof(glm::vec3), curVertexCount, vertexCount, pPosition)) {
+    return false;
+  }

   return true;
 }
```

`COpyData`関数に置き換えたことで、プログラムがスッキリしました。こんなに短ければ、残りはコピー&ペーストで簡単に書けちゃいます。さっそくやってみましょう。座標データをコピーするプログラムの下に、次のプログラムを追加してください。

```diff
   if (!CopyData(vboPosition, sizeof(glm::vec3), curVertexCount, vertexCount, pPosition)) {
     return false;
   }
+  if (!CopyData(vboColor, sizeof(glm::vec4), curVertexCount, vertexCount, pColor)) {
+    return false;
+  }
+  if (!CopyData(vboTexCoord, sizeof(glm::vec2), curVertexCount, vertexCount, pTexcoord)) {
+    return false;
+  }
+  if (!CopyData(ibo, sizeof(GLushort), curIndexCount, indexCount, pIndex)) {
+    return false;
+  }

   return true;
 }
```

>**【コピペの際は見落としに注意！】**<br>
>コピー&ペーストは便利ですが、細かな違いを見落としがちです。修正漏れや書き間違いがないか、しっかり見直すようにしましょう。

全てのデータをバッファオブジェクトにコピーしたら、ようやく`Primitive`を作成します。インデックスデータをコピーするプログラムの下に、次のプログラムを追加してください。

```diff
   if (!CopyData(ibo, sizeof(GLushort), curIndexCount, indexCount, pIndex)) {
     return false;
   }
+
+  primitives.push_back(Primitive(GL_TRIANGLES, static_cast<GLsizei>(indexCount),
+    sizeof(GLushort) * curIndexCount, curVertexCount));
+
+  curVertexCount += static_cast<GLsizei>(vertexCount);
+  curIndexCount += static_cast<GLsizei>(indexCount);

   return true;
 }
```

インデックスデータのバイトオフセットは要素のサイズと`curIndexCount`から計算できます。この値はすぐ上のプログラムでコピーしたデータの転送先オフセットと同じになります。頂点データの開始位置は、`curVertexCount`がそのまま使えます。

`Primitive`を追加したら、`curVertexCount`と`curIndexCount`にコピーしたデータ数を加算します。この計算によって、この2つのメンバ変数は「追加したデータの数」を表すようになります。なお、ここのキャストはコンパイラの警告を黙らせるために入れています。

### 1.8 <ruby>Get<rt>ゲット<rt></ruby>メンバ関数を定義する

`Get`(ゲット)メンバ関数は、`Add`で追加した`Primitive`を取得する関数です。基本的には指定されたインデックスに対応する`Primitive`を返すだけです。ただ、インデックスが正しいかどうかはチェックしなければなりません。それでは、`Add`メンバ関数の下に次のプログラムを追加してください。

```diff
   curIndexCount += indexCount;

   return true;
 }
+
+/**
+* プリミティブを取得する.
+*
+* @param n プリミティブのインデックス.
+*
+* @return nに対応するプリミティブ.
+*/
+const Primitive& PrimitiveBuffer::Get(size_t n) const
+{
+  if (n < 0 || n > static_cast<int>(primitives.size())) {
+    std::cerr << "[警告]" << __func__ << ":" << n <<
+      "は無効なインデックスです(size=" << primitives.size() << ").\n";
+    static const Primitive dummy;
+    return dummy;
+  }
+  return primitives[n];
+}
```

エラーが発生したときの対策はいろいろな考え方がありますが、今回はエラーメッセージを表示したあと、ダミーの`Primitive`を返すようにしてみました。

>**【エラーが起きたときはどうするべき?】**<br>
>これは本当に状況次第ですが、一般的にはエラーメッセージをコンソールウィンドウやファイルに出力してからプログラムを終了させます。エラーが起きたということは、その後も正しく動作するという保証はどこにもないからです。ただ、ゲームなどの場合、プログラムをいきなり終了すると、セーブができなくて進行状況が失われる、といったことが起こり得ます。そのため、表示がおかしくなる程度で済むのであれば、ダミーを表示させたりしてプログラムの実行を続けることもあります。

あと少しで`PrimitiveBuffer`クラスは完成です。頑張りましょう。

### 1.9 <ruby>BindVertexArray<rt>バインド・バーテックス・アレイ</rt></ruby>メンバ関数を定義する

`BindVertexArray`(バインド・バーテックス・アレイ)メンバ関数は、`VAO`をOpenGLコンテキストに割り当てます。

>**【OpenGLコンテキストに割り当てる = バインドする】**<br>
>ところで、毎回「OpenGLコンテキストに割り当てる」と書くのは、文章が長くなって読みづらいと思います。そこで、今後は「バインドする」のように書くことにします。

`Get`関数の定義の下に次のプログラムを追加してください。

```diff
     return dummy;
   }
   return primitives[n];
 }
+
+/**
+* VAOをOpenGLコンテキストにバインドする.
+*/
+void PrimitiveBuffer::BindVertexArray() const
+{
+  glBindVertexArray(vao);
+}
```

見てのとおり、`glBindVertexArray`を実行しているだけです。

### 1.10 <ruby>UnbindVertexArray<rt>アンバインド・バーテックス・アレイ</rt></ruby>関数を定義する

`UnbindVertexArray`(アンバインド・バーテックス・アレイ)関数は、`VAO`のバインドを解除します。`BindVertexArray`関数の定義の下に次のプログラムを追加してください。

```diff
   glBindVertexArray(vao);
 }
+
+/**
+* VAOのバインドを解除する.
+*/
+void PrimitiveBuffer::UnbindVertexArray() const
+{
+  glBindVertexArray(0);
+}
```

これも、`glBindVertexArray`を実行しているだけです。これで`PrimitiveBuffer`クラスは完成です。

### 1.11 頂点データを分割する

現在の頂点データは、すべての図形がひとかたまりの配列になっています。そのため、図形の区切りをコメントで<ruby>記<rt>しる</rt></rubh>しています。1章で説明したように、ひとかたまりになっていると、`Primitive`を作るときに面倒な計算をしなければなりません。

この計算をなくすために、図形ごとに配列を分けていきましょう。それと、第2回と第3回で作った三角形・四角形のデータはもう使わないので、一緒に削除することにします。`Main.cpp`を開き、座標データ(`positions`配列)を次のように書きかえてください(行数が多いので、一部を`︙`で省略しています)。

```diff
-/// 座標データ.
-const Position positions[] = {
-  // 地面
+/// 座標データ: 地面
+const glm::vec3 posGround[] = {
  {-20, 0, 20},
  { 20, 0, 20},
  { 20, 0,-20},
  {-20, 0,-20},
+};

-  // 木
+/// 座標データ: 木
+const glm::vec3 posTree[] = {
   { 0.00f, 5.0f, 0.00f},
   { 0.00f, 1.5f,-1.00f},
   {-0.87f, 1.5f, 0.50f},
   { 0.87f, 1.5f, 0.50f},
   { 0.00f, 4.0f, 0.00f},
   { 0.00f, 0.0f,-0.36f},
   {-0.31f, 0.0f, 0.18f},
   { 0.31f, 0.0f, 0.18f},
+};

-  // 家
+/// 座標データ: 家
+const glm::vec3 posHouse[] = {
   { 2.8f, 0.0f, 3.0f},
   { 3.0f, 4.0f, 3.0f},
   { 0.0f, 6.0f, 3.0f},
       ︙
   { 0.0f, 6.0f,-3.0f},
   { 0.0f, 6.0f, 3.0f},
+};

-  // 立方体
+/// 座標データ: 立方体
+const glm::vec3 posCube[] = {
   { 1,-1, 1},
   {-1,-1, 1},
   {-1, 1, 1},
       ︙
   {-1, 1,-1},
   {-1,-1,-1},
   { 1,-1,-1},
+};
-
-  {-0.3f, -0.3f, 0.5f},
-  { 0.2f, -0.3f, 0.5f},
-      ︙
-  { 0.33f + 0.5f, -0.5f, 0.5f},
-  { 0.0f + 0.5f,  0.5f, 0.5f},
-};

 /// 色データ.
 const Color colors[] = {
```

地面の座標データ配列の名前は`posGround`(ポス・グラウンド)としました。同様に、木は`posTree`(ポス・ツリー)、家は`posHouse`(ポス・ハウス)、立方体は`posCube`(ポス・キューブ)という名前を付けました。

<div style="border:solid 1px; background:#f0e4cd; margin: 1rem; padding: 1rem; border-radius: 10px">
<strong>【課題01】</strong><br>
<code>positions</code>と同じやり方で、<code>colors</code>配列を図形ごとに分けなさい。名前は<code>colGround</code>、<code>colTree</code>のように、先頭に<code>col</code>を付けなさい。
</div>

<div style="border:solid 1px; background:#f0e4cd; margin: 1rem; padding: 1rem; border-radius: 10px">
<strong>【課題02】</strong><br>
<code>positions</code>、<code>colors</code>と同じやり方で、<code>texcoords</code>配列を図形ごとに分けなさい。名前は<code>tcGround</code>、<code>tcTree</code>のように、先頭に<code>tc</code>を付けなさい。
</div>

<div style="border:solid 1px; background:#f0e4cd; margin: 1rem; padding: 1rem; border-radius: 10px">
<strong>【課題03】</strong><br>
<code>positions</code>、<code>colors</code>などと同じやり方で、<code>indices</code>配列を図形ごとに分けなさい。名前は<code>indexGround</code>、<code>indexTree</code>のように、先頭に<code>index</code>を付けなさい。
</div>

### 1.12 VAOをPrimitiveBufferで置き換える

頂点データとインデックスデータを図形ごとに分離したら、`PrimitiveBuffer`型の変数を追加し、頂点データを追加しましょう。

まず、`VAO`の作成に使うバッファオブジェクトを全て削除し、`PrimitiveBuffer`型の変数で置き換えます。これらのバッファオブジェクトの役割は、`PrimitiveBuffer`クラスが引き継ぎます。それでは、`VAO`を作成するプログラムを次のように書き換えてください。

```diff
   glDebugMessageCallback(DebugCallback, nullptr);

-  // VAOを作成する.
-  const GLuint positionBuffer = GLContext::CreateBuffer(sizeof(positions), positions);
-  const GLuint colorBuffer = GLContext::CreateBuffer(sizeof(colors), colors);
-  const GLuint texcoordBuffer = GLContext::CreateBuffer(sizeof(texcoords), texcoords);
-  const GLuint ibo = GLContext::CreateBuffer(sizeof(indices), indices);
-  const GLuint vao = GLContext::CreateVertexArray(positionBuffer, colorBuffer, texcoordBuffer, ibo);
-  if (!vao) {
+  PrimitiveBuffer primitiveBuffer;
+  if (!primitiveBuffer.Allocate(20'000, 80'000)) {
     return 1;
   }

  // パイプライン・オブジェクトを作成する.
  const GLuint vp = GLContext::CreateProgram(GL_VERTEX_SHADER, vsCode);
```

格納可能な頂点数は2万、インデックス数は8万としました。今のところは`1000`程度でも十分なのですが、あとになって不足しても困るので多めにしています。また、頂点数のほうが少ないのは、頂点を共有すれば頂点数を節約できるからです。


続いて頂点データを追加しましょう。`Allocate`の下に次のプログラムを追加してください。

```diff
   if (!primitiveBuffer.Allocate(20'000, 80'000)) {
     return 1;
   }
+  primitiveBuffer.Add(4, posGround, colGround, tcGround, 6, indexGround);

  // パイプライン・オブジェクトを作成する.
  const GLuint vp = GLContext::CreateProgram(GL_VERTEX_SHADER, vsCode);
```

上記のプログラムの`4`は頂点数、`6`はインデックス数です。これらはそれぞれ`posGround`配列の要素数と、`indexGround`配列の要素数になります。ということは、要素数を<ruby>数<rt>かぞ</rt></ruby>える必要があるわけです。もし要素数が変化したら数え直しです。

しかし、こんなことを手動でやるのは時間の無駄遣いです。人生は短いのですから、こういう雑事はコンピューターにやらせるべきでしょう。幸いなことに、`C++17`には`std::size`(エスティーディ・サイズ)という「要素数を数える」関数が追加されています。ということで、上記のプログラムを次のように書き換えてください。

```diff
   if (!primitiveBuffer.Allocate(20'000, 80'000)) {
     return 1;
   }
-  primitiveBuffer.Add(4, posGround, colGround, tcGround, 6, indexGround);
+  primitiveBuffer.Add(std::size(posGround), posGround, colGround, tcGround,
+    std::size(indexGround), indexGround);

  // パイプライン・オブジェクトを作成する.
  const GLuint vp = GLContext::CreateProgram(GL_VERTEX_SHADER, vsCode);
```

これで人生に使える時間が増えました。同様にして他の図形も追加しましょう。地面の頂点データを追加するプログラムの下に、次のプログラムを追加してください。

```diff
   primitiveBuffer.Add(std::size(posGround), posGround, colGround, tcGround,
     std::size(indexGround), indexGround);
+  primitiveBuffer.Add(std::size(posTree), posTree, colTree, tcTree,
+    std::size(indexTree), indexTree);
+  primitiveBuffer.Add(std::size(posHouse), posHouse, colHouse, tcHouse,
+    std::size(indexHouse), indexHouse);
+  primitiveBuffer.Add(std::size(posCube), posCube, colCube, tcCube,
+    std::size(indexCube), indexCube);

  // パイプライン・オブジェクトを作成する.
  const GLuint vp = GLContext::CreateProgram(GL_VERTEX_SHADER, vsCode);
```

>**【Getメンバ関数と追加順の関係】**<br>
>ここで図形を追加した順番が、`Get`メンバ関数に指定する番号になります。表示したい図形の番号分からないときは、ここのプログラムを見て順番を確認しましょう。

続いて、`VAO`のバインドを`PrimitiveBuffer`で置き換えます。`VAO`をバインドするプログラムを次のように書き換えてください。

```diff
     const glm::mat4 matView =
       glm::lookAt(viewPosition, glm::vec3(0), glm::vec3(0, 1, 0));

-    glBindVertexArray(vao);
+    primitiveBuffer.BindVertexArray();
     glBindProgramPipeline(pipeline);
     glBindSampler(0, sampler);

     // 木を描画.
```

バインドの解除も置き換えます。`VAO`のバインドを解除するプログラムを次のように書き換えてください。

```diff
     glBindTextureUnit(0, 0);
     glBindSampler(0, 0);
     glBindProgramPipeline(0);
-    glBindVertexArray(0);
+    primitiveBuffer.UnbindVertexArray();

     glfwPollEvents();
     glfwSwapBuffers(window);
```


ところで、後始末はプログラムの最後だけやればいい、というものではありません。プログラムを終了させるときは、必ずそれまでに作成済みのオブジェクトの後始末をする必要があるのです。そして、「プログラムを終了させるとき」というのは`main`関数の終わりだけとは限りません。`main`関数の中で`return`文を使っているすべての場所が該当します。当然、`return`文を追加するたびに、適切な後始末を書かなければなりません。

これはかなり面倒で、間違いを起こしやすいです。実際、`VAO`などの作成に失敗したときは何の後始末もしていません(気づきました？)。また、あるオブジェクトを作成する順番を後ろに移動した場合は、それより前にある後始末は全て削除しなければなりません。

しかし今後は`PrimitiveBuffer`クラスがバッファオブジェクトを管理してくれます。おかげで、もうこうした問題は起きません。こういうわけで、`VAO`などのオブジェクトを手動で削除するプログラムを消します。`VAO`を削除するプログラムを次のように書き換えてください。

```diff
   glDeleteProgram(fp);
   glDeleteProgram(vp);
-  glDeleteVertexArrays(1, &vao);
-  glDeleteBuffers(1, &ibo);
-  glDeleteBuffers(1, &colorBuffer);
-  glDeleteBuffers(1, &positionBuffer);
-  glDeleteBuffers(1, &texcoordBuffer);

   // GLFWの終了.
   glfwTerminate();
```

これで`PrimitiveBuffer`に頂点データを追加することができました。

### 1.13 PrimitiveをPrimitiveBufferで置き換える

最後に`primGround`などの`Primitive`型変数を`PrimitiveBuffer`で置き換えます。まず既存の`Primitive`型変数を全部消します。次のように描画データリストを削除してください。

```diff
   5, 6, 7, 7, 8, 5,
   11, 8, 9, 9, 10, 11,
 };
-
-/// 描画データリスト.
-const Primitive primGround(GL_TRIANGLES, 6, 0, 0); // 地面
-const Primitive primTree(GL_TRIANGLES, 21, 6 * sizeof(GLushort), 4); // 木
-const Primitive primHouse(GL_TRIANGLES, 42, 27 * sizeof(GLushort), 12);
-const Primitive primCube(GL_TRIANGLES, 36, 69 * sizeof(GLushort), 28);

 // 画像データ.
 const int imageWidth = 8; // 画像の幅.
 const int imageHeight = 8; // 画像の高さ.
```

次に`Primitive`型変数を使っていた部分を`PrimitiveBuffer`で置き換えていきます。地面を描画するプログラムを、次のように書き換えてください。

```diff
       glProgramUniformMatrix4fv(vp, locMatMVP, 1, GL_FALSE, &matMVP[0][0]);
       glBindTextureUnit(0, texGround);
-      primGround.Draw();
+      primitiveBuffer.Get(0).Draw();
     }

     // 家を描画.
```

`PrimitiveBuffer`に追加した`Primitive`を取得するには、`Get`メンバ関数に「`0`から始まる追加順の番号」を指定します。「地面」は最初に`Add`したので`0`番目ということです。もし「木」を取得するなら`1`、「家」なら`2`を指定します。

<div style="border:solid 1px; background:#f0e4cd; margin: 1rem; padding: 1rem; border-radius: 10px">
<strong>【課題04】</strong><br>
家、木、立方体の描画を<code>PrimitiveBuffer</code>を使うように置き換えなさい。
</div>

課題04が完了したらビルドして実行してください。以前と同じ画面が表示できたら成功です。

<div style="page-break-after: always"></div>

## 2. テクスチャをクラスにする

### 2.1 






